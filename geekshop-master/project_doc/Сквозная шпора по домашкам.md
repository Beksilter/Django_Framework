# Комментарии к урокам курса «Основы Django»

[TOC]

## Вступление

Этот текст - неотъемлемая часть кода, размещенного на GitHub - без него его не понять коментарии к каждому ДЗ размещены там-же. Из них собранг этот манул. 
(https://github.com/nikodim-an/geekshop)

Если есть проблемы с получением нужной версии - см. приложения→главное о Git.



## Урок 1 «Установка, настройка, создание репозитория»

###  Ознакомиться с версткой сайта, над которой будете работать.
Использую для работы верстку «от преподавателя».

### Подготовить проект

1. Создать папку geekshop-server; (у меня локально эта папка называется «Django»)
2. В папке geekshop-server создать виртуальное окружение;
3. Установить Django версии LTS — текущая версия и есть TLS, поэтому ставлю без указания версии;
4. Создать проект geekshop (в папке geekshop-server должно быть виртуальное окружение venv и сам проект geekshop);
5. Запустить сервер и убедиться, что все работает.

Поскольку создано виртуальное окружение, то сервер придется запускать bash скриптом или из IDE. Кроме того, в него и нужно устанавливать Django.

###  Создать приложение products (в методичке = mainapp).
Создавая это приложение хотел назвать его стандартом productsapp, но решил что рано или поздно запутаюсь, поэтому сделал как на видео.
После создания его нужно добавить в settings проекта в список INSTALLED_APPS.
Создать в папке с приложением папку templates, в которую будут складываться шаблоны HTML страниц.
В нем нужно также создать папку с названием приложения (но это не обязательно), которая и будет отвечать за хранение
шаблонов именно этого приложения. Если в приложении несколько страниц/фреймов/форм - то их. Это нужно для того, чтобы можно было использовать
одни и теже названия шаблонов в разных приложениях и при этом не путаться.
И уже в этом каталоге создать файл index.html в котором и будет шаблон главной страницы.
Тогда для другого окна/фрейма этого же приложения можно будет снова использовать index.html **(!)**.
Создадим отдельную страницу для продуктов products.html - которая тоже есть в верстке.
Занесем в эти файлы код из эквивалентных файлов верстки.

### Разместить шаблоны и статические файлы в соответствующих папках
Настроить проект – файл settings.py. Отредактировать файл диспетчера URL-адресов urls.py.

1. Добвим в settings.py

```
STATICFILES_DIRS = [
   BASE_DIR / 'static',
   ]
```

> как показал результат проверки - запятую ставить не нужно в списках, но обязательно нужно в кортежах

2. Добавим в urls.py код:

```
from products.views import index
from products.views import products

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index, name='index'),    # вот тут честно говоря не совсем понятно, обещали на следующем уроке разобрать
    path('products/', products, name='products'),
]
```

3. Исправим все пути в шаблонах, (везде где ссылки идут на статику - скрипты, картинки)

### Написать контроллер для всех страниц (главная и страница с продуктами)
Файл views.py в приложении mainapp (products). Проверить работу всех страниц проекта в черновом режиме (без стилей и изображений).  
добавим в views.py код:

```
def index(request):
    return render(request, 'products/index.html') # 'это тот путь, который после папки template. если бы небыло избыточной вложенности папок, то можно было бы написать просто 'index.thml'

def products(request):
    return render(request, 'products/products.html') # http://127.0.0.1:8000/products/ - по этому адресу заходит, а кнопками - нет.
```

По результату работы видно что, при попытке нажатия на кнопку на странице index которая должна вести на products перехода не происходит, поскольку ссылка на страницу products.html задана жестко с теле html кода. Соответственно данного файла по нужному пути нет и как результат выдается ошибка 404 протокола HTTP.

### Откорректировать пути к статическим файлам и адреса гиперссылок в меню.
Проверить, что все работает как положено (стили и изображения грузятся, гиперссылки работают).  
    сделал попутно в задании 4

### Подготовить проект для сдачи на GitHub:

      1. Сделать инициализацию гита;
      2. Добавить в проект файл .gitignore (в этот файл добавить .idea, __pycache__/, db.sqlite3) и README.md
      3. Связать проект с репозиторием;
      4. Создать ветку lesson1;
      5. Сделать commit и push (см. статьи, приложенные к уроку);
      6. Добавить меня (Vokler) в контребюторы вашего проекта и сделать New Pull Request на меня, чтобы я мог проверить ДЗ.

ps: вроде ничего не забыл…

> при проверке домашнего задания в пункте 4 была обнаружена ошибка, которая сосотяояла в том, что стояла запятая после последнего члена списка. Это нужно обязательно делать в кортежах, но в списках это не делается по pep, хотя работает

> Vokler - это преподаватель



## Урок 2 «Шаблон + контекст = html»

### 1. Организовать вывод динамического контента на страницах `index` и `products` (список товаров, заголовок страницы).

По главной странице сайта все просто. В context  попадет только заголовок страницы.

По странице с продуктами - в первую очередь нужно собрать список из справочников, в которых будут храниться необходимые данные (название, картинка, описание, цена). В итоге, взяв нужную информацию из страницы получаем следующий набор справочников:

```python
    {'name': 'Худи черного цвета с монограммами adidas Originals', 'img':'/static/vendor/img/products/Adidas-hoodie.png' ,'price': 6900, 'description': 'Мягкая ткань для свитшотов. Стиль и комфорт – это образ жизни'},
    {'name':'Синяя куртка The North Face', 'img':'/static/vendor/img/products/Blue-jacket-The-North-Face.png' , 'price': 23725, 'description': 'Гладкая ткань. Водонепроницаемое покрытие. Легкий и теплый пуховый наполнитель'},
    {'name':'Коричневый спортивный oversized-топ ASOS DESIGN', 'img':'/static/vendor/img/products/Brown-sports-oversized-top-ASOS-DESIGN.png' , 'price':3390, 'description':'Материал с плюшевой текстурой. Удобный и мягкий.'},
    {'name':'Черный рюкзак Nike Heritage', 'img':'/static/vendor/img/products/Black-Nike-Heritage-backpack.png', 'price': 2340, 'description':'Плотная ткань. Легкий материал.'},
    {'name':'Черные туфли на платформе с 3 парами люверсов Dr Martens 1461 Bex', 'img':'/static/vendor/img/products/Black-Dr-Martens-shoes.png', 'price':13590, 'description':'Гладкий кожаный верх. Натуральный материал.'},
    {'name':'Темно-синие широкие строгие брюки ASOS DESIGN', 'img':'/static/vendor/img/products/Dark-blue-wide-leg-ASOs-DESIGN-trousers.png', 'price':2890, 'description':'Легкая эластичная ткань сирсакер Фактурная ткань.'},
```

Изменив контролеры страниц, получим:

```python
def index(request):
    context = {
        'title': 'Интернет-магазин GeekShop (учебный проект на Django)'
    }
    return render(request, 'products/index.html', context)


def products(request):
    context = {
        'title': 'GeekShop - каталог наших предложений',
        'products': [
            {'name': 'Худи черного цвета с монограммами adidas Originals',
             'img': '/static/vendor/img/products/Adidas-hoodie.png', 'price': 6900,
             'description': 'Мягкая ткань для свитшотов. Стиль и комфорт – это образ жизни'},
            {'name': 'Синяя куртка The North Face', 'img': '/static/vendor/img/products/Blue-jacket-The-North-Face.png',
             'price': 23725,
             'description': 'Гладкая ткань. Водонепроницаемое покрытие. Легкий и теплый пуховый наполнитель'},
            {'name': 'Коричневый спортивный oversized-топ ASOS DESIGN',
             'img': '/static/vendor/img/products/Brown-sports-oversized-top-ASOS-DESIGN.png', 'price': 3390,
             'description': 'Материал с плюшевой текстурой. Удобный и мягкий.'},
            {'name': 'Черный рюкзак Nike Heritage',
             'img': '/static/vendor/img/products/Black-Nike-Heritage-backpack.png', 'price': 2340,
             'description': 'Плотная ткань. Легкий материал.'},
            {'name': 'Черные туфли на платформе с 3 парами люверсов Dr Martens 1461 Bex',
             'img': '/static/vendor/img/products/Black-Dr-Martens-shoes.png', 'price': 13590,
             'description': 'Гладкий кожаный верх. Натуральный материал.'},
            {'name': 'Темно-синие широкие строгие брюки ASOS DESIGN',
             'img': '/static/vendor/img/products/Dark-blue-wide-leg-ASOs-DESIGN-trousers.png', 'price': 2890,
             'description': 'Легкая эластичная ткань сирсакер Фактурная ткань.'},
        ]
    }
    return render(request, 'products/products.html', context)
```

Теперь нужно изменить сами шаблоны, чтобы они брали данные из передаваемой переменной context. В шаблоне главной страницы все ограничится вводом плейсходлера для титула страницы, а в продуктах заменим шесть одинаковых блоков, выводящих сведения о 6 товарах на конструкцию:

```html
{% for product in products %}
    <div class="col-lg-4 col-md-6 mb-4">
        <div class="card h-100">
            <a href="#">
                <img class="card-img-top"
                     src={{product.img}}
                     alt="">
            </a>
            <div class="card-body">
                <h4 class="card-title">
                    <a href="#">{{product.name}}</a>
                </h4>
                <h5>{{product.price}} руб.</h5>
                <p class="card-text">{{product.description}}</p>
            </div>
            <div class="card-footer text-center">
                <button type="button" class="btn btn-outline-success">Отправить в корзину</button>
            </div>
        </div>
    </div>
{%endfor%}
```

После этого цена станет выводиться без копеек, но эту проблему мы решим в следующем задании...

Запустив сервер наблюдаю картину нормального отображения странниц. Делаю коммит после выполнения этого задания домашней работы.

### 2. Поработать с шаблонными тегами и placeholder'ами (заглавные буквы, вывод текущей даты в шаблоне).

Сделаю заглавными буквами названия товаров, добавлю копейки в цену товара, а текущую дату выведу непосредственно в меню, туда где написано «Новинки». Для того, чтобы отобразить дату, передам ее внутри справочника context, а получу из модуля datetime.
Фильтры для вывода значений примут вид:

```html
<a href="#" class="list-group-item">Новинки на {{date|date:"d.m.Y"}}</a>
…
{{product.price|floatformat:2}}
…
{{product.name|upper}}
```

проверяю, делаю коммит...

### 3. Реализовать в проекте механизмы работы c URL-адресами.

поскольку urls.py уже имеет следующий вид (в главной своей части):

```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index, name='index'),
    path('products/', products, name='products'),
]
```

для корректной работы ссылок в шаблонах на внутренние страницы осталось привести их к виду:

```html
<a href="{% url 'products' %}">…</a>
и
<a href="{% url 'index' %}">…</a>
```

 остальные ссылки (Войти, Выйти, ЛК, Админка) пока не трогаю ибо страниц и функционала к ним еще нет.

### 4. Реализовать наследование шаблонов в проекте.

Шаблон создавал и подключал согласно инструкции из видео. файл шаблона назвал base_template.html. В отличие от видео статика пока остается статичной - разницы особой нет - просто потом в меньшем числе мест придется прописывать все дела связанные со статикой.  

проверил, закоммитил...

> в комьюнити версии PyCharm шаблонные теги не подсвечиваются...

### 5. Поработать со статическими файлами (убрать статическое объявление статики, переделав на динамическое отображение).

Делал по методичке и материалу урока. Тут вот что нужно отметить: тэги {% load static%} и {% static '…'%} не имеют никакого отношения к папке statica что есть в проекте. Да они работают с ней, да, именно в ней лежат файлы картинок и скриптов, но папка может называться вообще как угодно, а задается она в settings.py в константах STATIC_URL и STATICFILES_DIRS.

после того как статика подключена ее можно загрузить в страницу шаблона командой

```html
{% load static%}
```

и использовать командой

```html
{% load static%}
```

причем это теги нестандартные и они тоже не подсвечиваются в PyCharm комьюнити...

проверил, закоммитил...

### 6*. Организовать загрузку динамического контента в контроллер `products` из json файла (добавив json файл в папку *products/fixtures*).

Для решения поставленой задачи взял сформированный в первом задании список products, передаваемый в составе справочника context в шаблон страницы products.html.  Внем как-раз содержатся все необходимые данные.

Для формирования файла формата json написал небольшенький скрипт с использованием библиотеки json, который и выгрузил список в файл. Полученный файл положил по месту (products/fixtures) и дальше стал с ним работать. Результат и комментарии в коде.



## Урок 3 Модели, миграции, мультимедийный контент, ORM

### 1. Создать модели в проекте (обязательно должно быть поле с изображениями) и выполнить миграции.
Для создания моделей исправим файл models.py в папке с приложением на
```python
from django.db import models
'''
тут:
unque - уникальный
blank - флаг пустого значения (для стрингов "")
null - флаг значения nothing (none, null)
upload_to - название папки када загружать картинки
'''
'''
Поскольку подключены картинки (которые нужно загружать)
может понадобиться установить пакет pillow.
его можно поставить прамо в окружение через терминал командой pip.
Сообщение о необходимости такой установки выскочит при запуке сервера.
'''

class ProductsCategory(models.Model):
    name = models.CharField(max_length=64, unique=True)
    description = models.TextField(blank=True, null=True)

class products(models.Model):
    name = models.CharField(max_length=256)
    description = models.TextField(blank=True,null=True)
    # у нас картинка может быть пустой, поэтому нужно предусмотреть хренение специального изображения,
    # котороя будет отображаться для таких товаров и прописать его константой во вьювах (ну например blank_img).
    image = models.ImageField(blank=True, upload_to='products_img')
    price = models.DecimalField(max_digits=8, decimal_places=2, default=0)
    # чисто теоретически хранить склад прямо в таблице товаров неправильно,
    # но с практической точки зрения и при небольшом обороте может быть даже удобно
    # PositiveIntegerField - неотрицательное целое значение. Опять же если товары предполагают граммы
    # - то нужен гругой тип... или стандартные учетные единицы дял поставки в штуках.
    quantity = models.PositiveIntegerField(default=0)
    # теперь подкючение таблицы по ключу
    category = models.ForeignKey(ProductsCategory, on_delete=models.CASCADE)
    # тут предусмотрено каскадное удаление записей в таблице товаров при удалении их категории.
    # Это очень неправильно, но в учебных целях пойдет. На нормальном проекте лучше поставить
    # models.SET_NULL тогда при удалении категории у соответсвующих товаров это поле будет обнуляться.
    # или models.PROTECT - тогда удалить категорию будет не возможно, если к ней отнесен хоть один товар.

```
далее нужно выполнить миграции дял того, чтобы указанные в модели таблицы (и не только они, но и те, которые есть в наличии в проекте уже по умолчанию) создались.
для этого в терминале в папке проекта наберем:
```
 python manage.py makemigrations
```
после этого в папке migrations появится файл 0001_initial.py вообще таких фаайлов должно быть много и их, в случае пересоздания базы или ее рекреации нужно удалять и пересоздавать. после создания миграции нужно выполнить. это создаст в БД нужные таблицы и подготовит ее к работе.
все проблемы с переносом и преобразованием данных берет на себя ORM, поэтому особых проблем быть недолжно. нО еслиони возникают - то можно работать с SQL и напрямую... просто это несколько неудобно.
```
python manage.py migrate
```
после того как все миграции прошли и везде написалось «OK» таблицы создались и можно их заполнять (а для начала посмотреть через любой ДБ эксплорер, который понимает sqlite).
> все получилось - комичу...

> как оказалось сделал не совсем правильно (а обнарижил на следующем задании), один класс назвал с маленькой буквы products, второй тоже с ошибкой в имени, но его оставляю как есть, а буковку «p» заменил... Для этого пришлось откатиться на ветке на один коммит назад и поправить, после чего занова закоммитить... (и все бы ничего, но я при этом переопределил класс products, а значит он должен отвалиться... в общем вернулся и исправил.)

### 2. Поработать с моделями в консоли.
работаю в терминале из корневой папки с проектами Django, не запуская PyCharm, но используя окружение:

```bash
source venv/bin/activate
cd geekshop
python manage.py shell
```

после этого доступен шел для **прямого** обращения в базу данных или используя команды python, работающие через ORM

```bash
from products.models import Products, ProductCategory
```

и… **он ругнулся** потому, что у меня Products и ProductCategory, созданы как, соответсвенно, products и ProductsCategory...
```
вернулся в ветке lesson3: удалил последний коммит, перепушил (т.к. уже выгрузил на сервер), исправил, снова закоммитил... да... (вывод - смтори куда пишешь)
для справки, вдруг потом забуду:
    git reset --hard <коммит>  — вернуться на комит с номером (предыдущий)
    git push --force
```
теперь снова вхожу в шелл, импортирую классы...

```python
>>> from products.models import Products, ProductsCategory
>>> category = ProductsCategory(name='Мужская одежда', description = 'Одежда для мужчин')
>>> category.save()
>>> category = ProductsCategory(name='Женская одежда', description = 'Одежда для женщин')
>>> category.save()
```

так мы создали две категории товаров, мужская и женская одежда...

теперь другой способ, несколько более мудреный но и более удобный. Для этого идем через objects

```python
ProductsCategory.objects.create(name='Одежда унисекс')
```

запись в бд сразу создается, и показывается ее номер (id).
Кроме того, объект objects имеет в себе еще много методов, только один из которых create. Этот объект вообще-то предназначен дял прямого обращения к бд через sql, в том числе, и ей можно делать очень много всего....
основные функции:

```
all() - возвращает все объекты (записи) из модели (таблицы)
filter() - возвращает результаты фильтрации
get() - возвращает объект из БД
create() - создает объект
```
Однако работь напрямую с бд в терминале не удобно (нет подсветки синтаксиса и не показываются значения переменных, которые меняются), поэтому лучше это делать из PyCharm, но не из его терминала, а из Python Console (**при условии что верстия чарма - про!**). которая дефакто находится в состоянии shell даже если туда не входить - и вней есть и подсветка синтаксиса и индикаций значений. Если версия не pro, тогда придется мучаться без подсветки и других ништяков.
Дальше продолжаю в PyCharm, поскольку кое-какие преимущества все-же есть от работы в консоли...
```bash
>>> category = ProductsCategory.objects.get(id=1)
>>> category
<ProductsCategory: ProductsCategory object (1)>
```
переопределив метод __str__ у класса ProductsCategory и **перезапустив shell** получаем
```bash
>>> category = ProductsCategory.objects.get(id=1)
>>> category
<ProductsCategory: Мужская одежда>
```
для других методов (all и filter)
```bash
>>> category = ProductsCategory.objects.all()
>>> category
<QuerySet [<ProductsCategory: Мужская одежда>, <ProductsCategory: Женская одежда>, <ProductsCategory: Одежда унисекс>]>
>>> category = ProductsCategory.objects.filter(id=3)
>>> category
<QuerySet [<ProductsCategory: Одежда унисекс>]>
```
аналогичным образом добавляются данные и в другие таблицы
> есть определенные проблемы со вложенностью… нужно отдельно разобраться…
```
 product = Products.objects.create(name='Носки', description = 'Носки повседневные черные', category=1, quantity = 10, price = 70)
 ругается на целочисленное значение, если передать объект - тоже ругается… но я разбирусь, а где не разбирусь  - спрошу на занятии.
```

### 3. Создать суперпользователя. Настроить админку и поработать в ней.

Создал суперюзера

```bash
python manage.py createsuperuser
```
```
login: root
password: root
ругнулся на валидацию, но я настоял на том чтобы его создать...
```
для  того, чтобы работать с товарами, нужно в админке зарегистрировать наши две модели, которые есть в этом приложении. После этого они станут доступны после ввода логина и пароля.
забыл дописать:
```python
# products/admin.py

from django.contrib import admin
from products.models import Products, ProductsCategory;

admin.site.register(Products)
admin.site.register(ProductsCategory)
```
Добавил все 6 товаров + 1 подарочный (чтобы было). Картинки пока не вводил - сделаю это позже.
Товары завелись, комичу шаг.

### 4. Организовать работу с моделями в контроллерах и шаблонах.
Для того, чтобы корректно выводились данные из моделей (поскольку в них находятся ссылки на картинки), нужно чтобы они были введены и приложение могло работать с муьтимедиа. поэтому сперва нужно сделать следующее задание, а потом это.
Для решения поставленной задачи нужно:

* внести изменения в контроллер
* внести изменения в шаблон products для вывода товаров
* внести изменения в шаблон products для вывода категорий
после внесения изменений в контроллер его код стал выглядеть следующим образом:
```python
def products(request):
    import datetime
    from products.models import Products, ProductsCategory
    context = {
            'title': 'GeekShop - каталог наших предложений',
            'date': datetime.datetime.now().today(),
            'products': Products.objects.all(),
            'category': ProductsCategory.objects.all()
        }
    return render(request, 'products/products.html', context)
```
в шаблоне данные будут доступны из переменных:
```
product.name    -   наименование
product.description - описание
product.price - цена
product.image.url - адрес
, где product - это итерируемый объект из списка products
```
таким же образом получаются и значения из списка category (из него нам необходимо только наименование)
В части вывода единицы товара шаблон пример вид:
```html
{% for product in products %}
    <div class="col-lg-4 col-md-6 mb-4">
        <div class="card h-100">
            <a href="#">
                <img class="card-img-top"
                     src={{product.image.url}}
                     alt="">
            </a>
            <div class="card-body">
                <h4 class="card-title">
                    <a href="#">{{product.name|upper}}</a>
                </h4>
                <h5>{{product.price|floatformat:2}} руб.</h5>
                <p class="card-text">{{product.description}}</p>
            </div>
            <div class="card-footer text-center">
                <button type="button" class="btn btn-outline-success">Отправить в корзину</button>
            </div>
        </div>
    </div>
{%endfor%}
```
а в части вывода списка категорий:
```html
{%for cat in category%}
<div class="list-group">
    <a href="#" class="list-group-item">{{cat.name}}</a>
</div>
{%endfor%}
```

### 5. Настроить проект для работы с медиафайлами (добавить media в .gitignore).
Сделал этот пункт раньше предыдущего потому, что там нужно выводить картинки, которых у нас нет.
добавил в settigs.py:
```python
MEDIA_URL = '/media/'
MEDIA_ROOT= BASE_DIR / 'media'
```
urls.py принял вид:
```python
from django.contrib import admin
from django.urls import path

#' это не тот сеттингс что лежит в этой же папке! этот шире и тот в этот входит!
from django.conf import settings
from django.conf.urls.static import static

from products.views import index
from products.views import products

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index, name='index'),
    path('products/', products, name='products'),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root= settings.MEDIA_ROOT)

```
после этого графика грузитcя и складывается в папку /media/products_img. Загруженные файлы открываются пока только в админке. Теперь перейду к пердыдущему заданию, где нужно выводить контент на страницу.

### 6 (*). Создать диспетчер URL в приложении. Скорректировать динамические URL-адреса в шаблонах.
Пространство адресов нужно тогда когда страниц много и каждую из них не опишешь в urls.py например дял страниц инетрнет магазина, где у каждого товара будет свой уникальный адрес.
дял того, чтобы завести пространство URL для приложения (а в рамках проекта может быть и несколько пространств имен) нужно:
* Создать urls.py в корне приложения и описать в нем пространство имен
* подключить это пространство в главный urls.py проекта
* исправить ссылки на страницы из пространства с учетом нового имени.
1. создаем ссылки дял пространства:
```python
from django.urls import path
from products.views import products
# from products.views import index # не записываем потому что он включен в главный urls.py

app_name = 'products'
urlpatterns = [
    path('',products, name = 'index') # но это уже index не от сайта а от пространства адресов products
]
```
2. подключаем в модуль с адресами (+ см. комментарии в коде!):
```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index, name='index'),
    path('products/', include('products.urls', namespace='products'), name='products'), # это объявление глобального адреса который стал пространством, и берется он из urls из папки products
]
```
3. Правим ссылки. везде где ссылаются на products, нужно ссылаться на products:index (именно этот адрес теперь имеет страница products)

### 7 (*). Организовать загрузку данных в базу из файла (Django fixtures).

Фикстуры - это файлы в которых содержится некоторый набор данных, которые можно быстро сохранить в базу данных. Они представляют собой выгрузку мз модели в формате json. дял каждой модели - свой фикстур. Набор фикстуров можно составить любой (наиболее критичные начальные данные, обеспечивающие некоторый средний функционал, достаточный например для быстрого развертывания или тестирвоания).

Фикстуры хранятся непосредственнов приложении из котрого они сделаны, как правило в папке fixtures. Если дял проекта предусмотрено окружение - то нужно создавать фикстуры из окружения. Поскольку в бд хранятся не сами изображения а ссылки на них, то фикстур будет иметь маленький объем, и при этом не перенесет картинки (тоесть при развертывании картинок не будет но будет набор данных с которыми приложение точно будет работать.)

Создать фикстур можно так (делается в терминале, возможно даже скриптом):

```bash
python manage.py dumpdata <модель> > <файл>
например (в моем случае, папка существует)
python manage.py dumpdata products.Products > products/fixtures/products.json
python manage.py dumpdata products.ProductsCategory> products/fixtures/category.json
```

создание и обновление фикстур - процесс быстрый и вполне автоматизируемый, а вот восстановление - нет... (хотя и несложный)

для восстановления (например после удаления бд) нужно:

* создать бд (а она создается при запуске сервера)
* выполнить миграции (потому что нет таблиц, а они появятся после миграций)
* создать суперпользователя (потому, что бд фактически нет, а значит нет и пользователей→войти в БД не получится)
* загрузить каждый фикстур

итак по командам это выглядит так:
```bash
python manage.py migrate
python manage.py createsuperuser
python manage.py loaddata products/fixtures/category.json
python manage.py loaddata products/fixtures/products.json
```
проверяю, комичу.

## Урок 4 «Аутентификация и регистрация пользователя»
### 1. Создать модель пользователя в проекте. Обязательно добавить поле с изображением. Выполнить настройки в файле конфигурации.

Для того, чтобы это сделать нужно добавить приложение отвечающее за работу с пользователями (их авторизацию) и уже в нем добавлять модель (а по сути расширять, поскольку работа с пользователями уже налажена в стандартной админке.)
Пусть добавленное приложение будет «users». Тогда модель для этого приложения будет выглядеть так:
```python
from django.db import models
from django.contrib.auth.models import AbstractUser
# Импортировали абстрактного пользователя потому что нужно от него наследоваться с целью расширения (добавим картинку)

class users(AbstractUser):
    image = models.ImageField(blank=True, upload_to='users_images')
```
Поскольку мы создали новую пользовательскую модель, то ее теперь нужно прописать в файле settings в константу AUTH_USER_MODEL:
```python
AUTH_USER_MODEL = 'Users.User'
```
> переопределять модель пользователя нужно тогда, когда существующая не устраивает (например по составу). **НО делать это на работающем проекте после разработки части моделей - достаточно проблематично**. На маленьких проектах вполне хватает стандартной модели, но на больших - ее, как правило меняют.

> **если имеется подозрение на тему того, что в процессе работы нам может не хватить стандартной модели AbstractUser, то при старте проекта, до того, как начинать его ваять вообще - первое что нужно сделать - новую модель пользователей и подключить ее в settings.py** Это нужно для того, чтобы получить базу данных сразу с «правильно» построенными таблицами, которые содержат нужные поля в части пользователей. Иначе если попробовать пересоздать миграции - выпадет ошибка, которую можно решить только удалением БД.

Поскольку мы изменили модель, то нужно занова сделать миграции, и провести их.
> это опять же представляет некоторую сложность поскольку сделать это на бд в которой есть данные не удалив их - невозможно. Поэтому существует технология фикстур, которой мы на прошлом занятии пользовались. Данные в нашем случае уже выгружены, осталось удалить БД, сделать миграции, провесnи их. После этого нужно загрузить данные, по пути создав суперпользователя - отредактировать его данные (в данном случае это картинка) можно позже, когда будет получен доступ к админке.

Для этого удалим бд, создадим миграции, проведем их, создадим суперпользователя, загрузим данные из фикстур, войдем в админку стандатрыми средствами через 127.0.0.1/admin и оценим результат. Но в админке сразу пользователей нет, покальку мы не зарегистрировали новую модель в файле admin.py (который в новом приложении), а старая (которая AbstractUser) уже не существует (точнее существует, но пустая, а ее меcто в бд заняла свежесозданная, но админка об этом не знает).
Зарегистрируем модель:

```python
from django.contrib import admin
from users.models import Users
admin.site.register(Users)
```
Рестартанем сервер, обновим страницу. 

### 2. Реализовать механизм аутентификации и авторизации в проекте.
> Это два разных процесса! Первый - определение пользователя и того есть ли такой пользователь в системе (может ли быть) а авторизация - процесс раздачи пользователю прав на то или иное действие! Как правило последнее происходит после ввода имени пользователя и пароля. сперва происходит аутентификация, а потом - авторизация. А после этого происходит АУДИТ - процесс контроля того что делает пользователь и что ему из того, что он делает можно делать, а чего нет.
Для аутентификации и авторизации нужно сделать следующее:

1. добавить шаблоны страниц ввода имени пользователя и пароля, а также регистрации (или взять готовые из верстки, обратив внимание на указанные статические адреса, пути и подгрузку статики, а лучше сделать базовый шаблон, но у нас это 5 задание).
2. сделать для них контроллеры (с учетом пространства адресов для приложения users)
3. подключить новое пространсво адресов в urls.py проекта и проверить чтобы страницы выводились
4. сделать форму (это не страница, это ФОРМА, где формируются части html кода для ее вывода). Подробнее далее.
5. подключить форму для передачи в контекст страницы login (во вьюшке)

> выше говорилось про форму, которую нужно создать в django форма создается не в html (там тоже форма, но в виде тегов), а отдельно и является по сути - классом в котором хранятся значения (он преднеазначен дял обмена данными между формой на странице и самой django), и потом подключается в шаблон страницы в ту форму, которую создают. Для того, чтобы сделать форму нужно добавить в корень приложения модуль forms.py и внем описать все формы которые понадобятся.
```python
from django.contrib.auth.forms import AuthenticationForm
from django import forms

from users.models import Users

class UserLoginForm(AuthenticationForm):
    username = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите имя пользователя'}))
    password = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите пароль'}))
    class Meta:
        model = Users
        fields = ('username', 'password')
```
> Есть два вида запросов (на самом деле больше, но эти нужны сейчас), GET и POST - первый получает данные от сервера, второй отправляет данные на сервер. (подробней в методичке). сперва срабатывает GET, потом - POST
(подробно о том как работает связка HTML формы и формы django смотреть в приложении (тот файл который состален из большого числа этих.))
Остается только прописать правильно параметры формы в HTML и правильно построить контекст ов вьюшке, а также обработать запрос POST.

```python
from django.shortcuts import render, HttpResponseRedirect
from users.forms import UserLoginForm
from django.contrib import auth
from django.urls import reverse

def login (request):
    # это обработка POST запроса
    if request.method == 'POST':
        form = UserLoginForm(data=request.POST)
        print(form)
        if form.is_valid(): # если данные в форме валидны (а данные тут - кусок html кода)
            username = request.POST['username']
            password = request.POST['password']
            user = auth.authenticate(username=username, password=password) # результат прохождения аутентификации
            print(user)
            if user and user.is_active:
                auth.login(request, user) # авторизоваться этим пользователем
                return HttpResponseRedirect(reverse('index')) # перенаправить на главную
    else:
        form = UserLoginForm() # фактически перенаправление на GET запрос
    
    # это обработка GET
    context = {
        'title': 'Авторизация в GeekShop',
        'form': form,
    }
    return render(request, 'users/login.html', context)
```
И html код части шаблона (а точнее формы), где производится ввод/вывод
```html
<form action="{% url 'users:login' %}" method = "post">
    {% csrf_token %}
    <!--выше прописана обязательная часть кода она говорит, что данные 
    передались в контроллер страницы «логин», где они и будут обрабатываться -->
    <div class="form-group">
        <label class="small mb-1" for="{{form.username.id_for_label}}">Имя пользователя</label>
        <!-- для поля ввода стиль задается в файле form.py -->
        {{form.username}}

    </div>
    <div class="form-group">
        <label class="small mb-1" for="{{f}}">Пароль</label>
        {{form.password}}
    </div>
    <div class="form-group d-flex align-items-center justify-content-between mt-4 mb-0">
        <a class="small" href="#">Забыли пароль?</a>
        <input class="btn btn-primary" type="submit" value="Авторизоваться">
<!-- тут еще главное чтобы кнопка на форме была типа «submit» -->
    </div>
</form>
```

### 3. Реализовать механизм регистрации пользователя. И не забыть добавить logout.
Решаем аналогично предыдущему (в части подключения формы и обмена данными с ней). Только наследоваться нужно от UserCreationForm. Чтобы потом не искать привиду код.
форма:

```python
class UserRegistrationForm(UserCreationForm):
    username = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите логин'}))
    password1 = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите пароль'}))
    password2 = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Подтвердите пароль'}))
    email = forms.CharField(widget=forms.EmailInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите адрес эл. почты'}))
    first_name = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите имя'}))
    last_name = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите фамилию'}))

    class Meta: # Это доопределение класса Meta (внутреннего класса Django. см. приложение)
        model = Users
        fields = ('username', 'email', 'first_name', 'last_name', 'password1', 'password2', )
        # пароли 1 и 2 - это пароль и его подтверждение. а когда просто пароль -это уже введенный пароль и записанный в БД
```
вьюха:
```python
def registration(request):
    if request.method == 'POST':
        form=UserRegistrationForm(data=request.POST)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect(reverse('users:login'))
        else:
            print(form.errors)
    else:
        form = UserRegistrationForm()

    context= {
        'title': 'GeekShop - Регистрация',
        'form': form,
    }
    return render(request,'users/register.html', context)
```
А в шаблоне страницы - все одинакия с тем, что имелось в предущем задании
**По поводу логаута.**
отлогониться можно используя код контроллера:

```python
def logout(request):
    auth.logout(request)
    return HttpResponseRedirect(reverse('index'))
```
причем это код контроллера из users. его нужно подключить в urls от users и везде где «отлогониться» встречается в шаблонах - нужно дать ссылку.
Отображение кнопок в шапке главного шаблона products строится на использовании глобального класса user, у которого есть значение is_authenticate
и настраивается непосредственно в шаблоне (он у нас один - базовый от products):

```html
<li class="nav-item">
    <a class="nav-link" href="{% url 'products:index' %}">Каталог <i class="fas fa-shopping-bag"></i> </a>
</li>
{% if user.is_authenticated%}
    <li class="nav-item">
        <a class="nav-link" href="auth/profile.html">{{user.username}}
            <i class="fas fa-user-circle"></i>
        </a>
    </li>
    <li class="nav-item">
        <a class="nav-link" href="admin/admin.html">
            <i class="fas fa-users-cog"></i>
        </a>
    </li>
    <li class="nav-item">
        <a class="nav-link" href="{% url 'users:logout' %}">Выйти <i class="fas fa-sign-out-alt"></i></a>
    </li>
{% else %}
    <li class="nav-item">
        <a class="nav-link" href="{% url 'users:login' %}">Войти <i class="fas fa-sign-in-alt"></i></a>
    </li>
{% endif %}
```
проверил, закоммитил...

### 4*. Создать base.html для login.html и register.html в templates папке приложения users.
Выполнил по инструкции из 2-го урока (задание 4(2)).
Закоммитил.

### 5*. Разобраться с механизмом валидации данных формы. Создать свои валидаторы.
Пользовательский валидатор...
прочитал документацию и изменил модуль с моделью  Users следующим образом:

```python
from django.db import models
from django.contrib.auth.models import AbstractUser
# Импортировали абстрактного пользователя потому что нужно от него наследоваться с целью расширения (добавим картинку)

# Проба пера с валидатором
def OnlyRusText(value):
    """
    Типа «мой собственный» валидатор, который не пропускает строки с английскими буквами и с заглавными
    PS: понимаю что можно было по-другому и догадываюсь что что-то софункциональное уже есть в Django
    но попросили создать валидатор с нуля....
    И он работает… хоть и алгорим дубовый... ничего умней в голову почему-то не пришло… 
    """
    from django.core.exceptions import ValidationError
    def match(text):
        alphabet=set('абвгдеёжзийклмнопрстуфхцчшщъыьэюя')
        for i in text:
            if i not in alphabet: return False
        return True

    if not match(value):
        raise ValidationError('%s ЭТО НЕ РУССКИЙ ТЕКСТ!' % value)

# модель пользователей
class Users(AbstractUser):
    image = models.ImageField(blank=True, upload_to='users_images')
    first_name = models.CharField(max_length=25, validators=[OnlyRusText]) # Это нужно удалить
    last_name = models.CharField(max_length=25, validators=[OnlyRusText]) # Это тоже нужно удалить
```
валидатор проверяет чтобы имя и фамилия были введены только рускими буквами и только маленькими.
при неверном вводе формирует ошибку валидации:
```html
<ul class="errorlist"><li>last_name<ul class="errorlist"><li>иванas ЭТО НЕ РУССКИЙ ТЕКСТ!</li></ul></li></ul>
```
закоммитил, отключил эту «валидацию» и снова закоммитил



## Урок 5 

### 1. Реализовать механизм редактирования информации о пользователе (личный кабинет) в проекте. Обязательно реализовать механизм загрузки аватара пользователя.

Для решения этой задачи:

1. создадим страницу личного кабинета в шаблонах. Наследуем ее от базового шаблона products потому, что в нем есть шапка, подвал и содержимое. В качестве исходника возьмем страницу profile.html из базовой верстки.
2. Напишем контроллер вывода:

```python
def profile(request):
    if request.method == 'POST':
        form = UserProfileForm(instance = request.user, data = request.POST, files= request.FILES) # сказали что менять будем у этого пользователя, что пришел в запросе и работать с приложенным в запросе файлом.
        if form.is_valid():
            form.save()
            return HttpResponseRedirect(reverse('users:profile'))
    else:
        form = UserProfileForm(instance=request.user) # передали текущего пользователя дял отображания его «ТТХ»
    context = {
        'title': 'Профиль пользователя',
        'form': form,
    }
    return render(request, 'users/profile.html', context)
```

3. После этого пропишм ее в urls приложения users:

```python
urlpatterns = [
    path('login/', login, name = 'login'),
    path('registration/', registration, name = 'registration'),
    path('logout/', logout, name= 'logout'),
    path('prifile/', profile, name='profile'),
]
```

4. изменим базовый шаблон дял вывода профиля пользователя (назначим кнопку в шапке, при нажатии на которую будет выводиться профайл)  
   ** на этом этапе должна выводится страница профайла**  
5. Создадим форму для ввода-вывода значений (на основе UserChangeForm).

```python
class UserProfileForm(UserChangeForm):
    username = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', 'readonly':True}))
    email = forms.CharField(widget=forms.EmailInput(attrs={
        'class': 'form-control py-4', 'readonly':True}))
    first_name = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', }))
    last_name = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', }))
    image = forms.ImageField(widget=forms.FileInput(attrs={
        'class': 'custom-file-input'}), required=False)

    class Meta:
        model = Users
        fields = ('username', 'email', 'first_name', 'last_name', 'image')
```

6. укажем значения переменных из созданной формы для вывода в страницу профайла.
   проверим вывод формы и ее функционал.

```html
<form action="" method="post" action="{% url 'users:profile' %}"  enctype= "multipart/form-data">  
<!--
    последний нужен для того чтобы обновлялась картинка
-->
    {% csrf_token %}
    <div class="form-row">
        <div class="col-lg-6">
            <div class="form-group">
                <label class="small mb-1" for="{{form.first_name.id_for_label}}">Имя</label>
                {{form.first_name}}
            </div>
        </div>
        <div class="col-lg-6">
            <div class="form-group">
                <label class="small mb-1" for="form.last_name.id_for_label">Фамилия</label>
                {{form.last_name}}
            </div>
        </div>
    </div>
    <div class="form-row mb-2">
        <div class="col-lg-12">
            <div class="custom-file">
                {{form.image}}
                <label class="custom-file-label" for="form.image.id_for_label">Выберите изображение</label>
            </div>
        </div>
    </div>
    <div class="form-row">
        <div class="col-lg-6">
            <label class="small mb-1" for="form.username.id_for_label">Имя пользователя</label>
            {{ form.username }}
        </div>
        <div class="col-lg-6">
            <label class="small mb-1" for="form.email.id_for_label">Адрес электронной
                почты</label>
            {{form.email}}
        </div>
    </div>
    <div class="form-row">
        <div class="col-lg-12" style="margin-top: 33px;">
            <input class="btn btn-info btn-block" type="submit" value="Сохранить">
        </div>
    </div>
</form>
```

### 2. Добавить обработку ошибок для страниц авторизации и регистрации. И добавить сообщения об успешных действиях.

здесь буду делать показ сообщений на страницах авторизации и регистрации, а так-же сообщение об успешном сохранении данных в профайле.
начнем с формы регистрации. в ней ошибки будут выводится перечнем так, как они пришли от фремворка.

1. в сеттингах поменять LANGUAGE_CODE на 'ru-ru'
2. исправить шаблоны используя forms.errors (кусок html кода с перечнем ошибок)

```html
{% if form.errors%} 
<!--
сперва обрабатываются валидаторы каждого поля и до проверки валидации формы
дело доходит только при сохранении!!
-->
    <div class="alert alert-warning alert-dismissible fade show" role="alert"
         style="margin-top: 50px;">
        {{form.errors}}
        <button type="button" class="close" data-dismiss="alert" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
    </div>
{% endif %}

```

для форм авторизации и личного кабинета логичней использовать вывод не ошибок, а сообщений.
на примере формы авторизации:

```html
{% if form.errors %}
<div class="alert alert-warning alert-dismissible fade show" role="alert"
     style="margin-top: 50px;">
    {%for error in form.non_field_errors%}  
    <!-- перебираем эти ошибки именно потому что нас интересуют ошибки неопределенного рода -->
        {{error}}
        <button type="button" class="close" data-dismiss="alert" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
    {%endfor %}
</div>
{% endif %}
```

теперь выведем сообщение в то-же поле куда выводим ошибку, но сообщение будет выводиться только тогда, когда пользователь приходит на форму авторизации после успешной регистрации. Поскольку мы будем отправлять сообщение из контроллера страницы регистрации (именно оттуда мы редиректимся) то измениться как сам контроллер, так и код страницы.  
Контроллер:

```python
def registration(request):
    if request.method == 'POST':
        form=UserRegistrationForm(data=request.POST)
        if form.is_valid():
            form.save()
            # создадим сообщение
            messages.success(request, 'Вы успешно зарегистрировались!') 
            # теперь это сообщение стало доступно из шаблона
            return HttpResponseRedirect(reverse('users:login'))
        # else:
            # print(form.errors) # это мы вывели ошибки валидации формы
    else:
        form = UserRegistrationForm()

    context= {
        'title': 'GeekShop - Регистрация',
        'form': form,
    }
    return render(request,'users/register.html', context)
```

Код страницы:

```html
{% if messages %}
<div class="alert alert-success alert-dismissible fade show" role="alert"
    style="margin-top: 50px;">
    <!-- здесь изменился класс ошибки - смотрим его в привязанном CSS 
    (тот что подходит по мсыслу)
    -->
    {% for message in messages%}
        {{message}}
    {%endfor%}
</div>
{% endif %}
<!-- это история про ошибки-->
{% if form.errors %}
<div class="alert alert-warning alert-dismissible fade show" role="alert"
     style="margin-top: 50px;">
    {%for error in form.non_field_errors%}  
    <!-- перебираем эти ошибки именно потому, что нас 
    интересуют ошибки неопределенного рода -->
        {{error}}
        <button type="button" class="close" data-dismiss="alert" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
    {%endfor %}
</div>
{% endif %}
```

аналогичным образом сделаем вывод сообщения для страницы личного канибета.

```python
def profile(request):
    if request.method == 'POST':
        form = UserProfileForm(instance = request.user, data = request.POST, files= request.FILES) # сказали что менять будем у этого пользователя, что пришел в запросе и работать с приложенным в запросе файлом.
        if form.is_valid():
            form.save()
            messages.success(request, 'Изменения успешно сохранены!')
            return HttpResponseRedirect(reverse('users:profile'))
    else:
        form = UserProfileForm(instance=request.user) # передали текущего пользователя дял отображания его «ТТХ»
    context = {
        'title': 'Профиль пользователя',
        'form': form,
    }
    return render(request, 'users/profile.html', context)
```

```html
<!-- сообщение, если оно есть. Добавить в любом «адекватном»
месте страницы-->
{% if messages %}
<div class="alert alert-success alert-dismissible fade show" role="alert"
    style="margin-top: 50px;">
    {% for message in messages%}
        {{message}}
    {%endfor%}
</div>
{% endif %} 
```

проверяю, комичу.

### 3. Создать приложение корзины. Создать новую модель для корзины.

Создали приложение:

```bash
python manage.py startapp baskets
```

**зарегистрировали его в установленных в settings.py**  
создали модель:

```python
from django.db import models
from users.models import Users
from products.models import Products

# Create your models here.

class Basket(models.Model):
    user = models.ForeignKey(Users, on_delete = models.CASCADE)
    product = models.ForeignKey(Products, on_delete = models.CASCADE)
    quantity= models.PositiveIntegerField(default=0)
    created_timestamp = models.DateTimeField(auto_now_add = True) # Это
    # нужно для того чтобы в любой момент можно было поднять историю
    # о том, когда пользователь добавил товар в корзину.
    # а дял того, чтобы можно было проверять когда он ее изменял -
    # аналогичным образом можно создать modify_timestamp и при каждом
    # изменении это значение пререписывать.

    def __str__(self):
        return f'корзина для {self.user.username}| Товар {self.product.name}'

```

сделали миграции и провели их:

```bash
python manage.py makemigrations
python manage.py migrate
```

Коммичу. Будут ошибки - на следующем задании вылезут…

### 4. Добавить включенный шаблон basket.html в profile.html. Реализовать вывод товаров корзины.

Решаем следующим образом:

 - создаем шаблон basket.html в шаблонах корзины, в него выносим все лишнее из profile.html.
 - делаем его включенным в profile.html (получится что то что убрали, то и добавили, но уже как отдельную страницу)
 - выводим товары в корзину.
   первое и второе - делается аналогично сделанному ранее и по методичке, а последнее - результат правки контроллера и шаблона.
   поскольку корзину мы видим из контролера profile то и править будем его для корректного вывода ее содержимого. Данные переданные в profile будут автоматически проброшены в basket, который (шаблон) является включенным в profile.
   Далее нужно добавлять товары в корзину, но это следующее задание. код контроллера:

```python
def profile(request):
    if request.method == 'POST':
        form = UserProfileForm(instance = request.user, data = request.POST, files= request.FILES) # сказали что менять будем у этого пользователя, что пришел в запросе и работать с приложенным в запросе файлом.
        if form.is_valid(): 
            form.save()
            messages.success(request, 'Изменения успешно сохранены!')
            return HttpResponseRedirect(reverse('users:profile'))
    else:
        form = UserProfileForm(instance=request.user) # передали текущего пользователя дял отображания его «ТТХ»
    context = {
        'title': 'Профиль пользователя',
        'form': form,
        'backets': Basket.objects.all(), # тут опечатка в ключе
#        'baskets': Basket.objects.filter(user=request.user), 
        # этот фильтр, чтобы выводились только по заданному пользователю. 
    }
    return render(request, 'users/profile.html', context)
```

На текущем этапе отображается пустая корзина, а дальше будет видно что не так. если будет какая-нибудь ошибка — она вылезет дальше и там я ее пофиксю.
пока коммичу...

### 5. Реализовать механизм добавления и удаление товара корзины.

поскольку происходит работа с корзиной, то добавлять будем контроллер корзины, но он не будет ничего отображать, а будет добавлять в корзину товар (точнее создавать новую «индивидуальную» корзину для каждого товара)
контроллер примет вид:

```python
def basket_add(request, product_id):
    product = Products.objects.get(id=product_id) # взяли нужный продукт (с которого на кнопку нажали)
    baskets = Basket.objects.filter(user = request.user, product=product) 
    # отфильтровали корзину по нужному продукту и пользователю
    # если есть - то нужно +=1, если нет, то нужно создать 1
    if not baskets.exists():
        Basket.objects.create(user = request.user, product = product, quantity = 1) # создали запись в корзине на 1 единицу товара
        return HttpResponseRedirect(request.META.get('HTTP_REFERER')) # вернулись туда откуда пришли
    else:    
        basket = baskets.first() # взяли любой, потому что первый - он и последний.
        basket.quantity+=1 # +=1..
        basket.save() # сохранили изменение количества
        return HttpResponseRedirect(request.META.get('HTTP_REFERER')) # вернулись туда откуда пришли
```

теперь нужно изменить шаблон products для добавления товаров корзины.. (где кнопка у каждого товара)

```html
<div class="card-footer text-center">
    <a href = "{% url 'baskets:basket_add' product.id %}" class="btn btn-outline-success">Отправить в корзину</a>
</div>
```

кроме того, нужно создать namespace для baskets, прописав глобальные и локальные (для приложения) адреса.
теперь осталось изменить baskets.html дял отображения «корзин» в корзине.

```html
{%if baskets%}
<div class="col-lg-5">
    <h4 class="mt-3 mb-3 d-flex justify-content-between align-items-center mb-3">
        Корзина <span class="badge badge-secondary badge-pill">3</span>
<!--
        исправить общее количесвто
-->
    </h4>
    <div class="card mb-3">
        {%for basket in baskets%}
            <div class="card-body">
                <h5 class="card-title">{{basket.product.name}}</h5>
                <p class="card-text">{{basket.product.description}}</p>
            </div>
            <ul class="list-group list-group-flush">
                <li class="list-group-item bg-light">
                    <div class="row text-center">
                        <div class="col-lg-4">
                            <input name="basketID" type="number" class="form-control"
                                   value="{{basket.quantity}}" min="0">
                        </div>
                        <div class="col-lg-4">{{basket.product.price}}</div>
                        <div class="col-lg-4">
                            <a href="#">
                                <i class="fas fa-trash"></i>
                            </a>
                        </div>
                    </div>
                </li>
            </ul>        
        {%endfor%}
        <!--
        исправить кнопку корзины
        -->
    </div>
    <div class="card mb-3">
        <div class="card-footer">
            <p class="float-left">Итого</p>
            <h4 class="float-right">2 390 руб.</h4>
<!--
            исправить общий подсчтет стоимости
-->
        </div>
    </div>
    <button type="button" class="btn btn-success btn-lg float-right">Оформить</button>
</div>
{%else%}
    <h4 class="mt-3 mb-3">
        Корзина пуста
        <!-- не стал делать по центру -->
    </h4>
{%endif%}

```

**перейдем к удалению товара из корзины.**
Для этого создадим еще один контроллер и прописываем его в urls приложения basket:

```python
def basket_remove(request, id): #здесь id это id корзины а не товара.
    basket = Basket.objects.get(id=id)
    basket.delete()
    return HttpResponseRedirect(request.META.get('HTTP_REFERER'))
```

кроме этого подключаем ссылку на иконку на странице «корзин»

```html
<div class="col-lg-4">
    <a href="{% url 'baskets:basket_remove' basket.id %}">
        <i class="fas fa-trash"></i>
    </a>
</div>
```

после этого в корзину добавляются и из нее удаляются товары и пока не изменяется количество товара.
коммичу. перехожу к следующему заданию.

### 6. Создать метод sum(), который будет отвечать за вывод итоговой стоимости для товара.

подсчитать значение суммы по товарной позиции можно в контроллере, но при работе с фреймворком рекомендуется максимум логики выносить в модель. Поэтому будем создавать там.

```python
    def sum(self): 
        # здесь сделать метод в который будет что-то передаваться не 
        # получится. Его тогда невозможно будет вызвать из html
        # в этом случае нужные данные считаются в контроллере
        return self.quantity*self.product.price
```

вызов из html

```html
 <div class="col-lg-4">{{basket.sum}}</div>
```

> Вызов делается именно так потому, что нельзя передать параметры. К функци при этом обращаются как к переменной.

Осталось подсчитать общую стоимость покупки и общее количесвто «мест» во всех товарных позициях.
коммичу. перехожу к следующему заданию.

### 7*. Написать в модели корзины методы для определения общего количества и стоимости добавленных товаров. Вывести эти величины в шаблоне.

Как вариант предложил способ описания указанных методов в модели корзины.

```python
    # методы корзины как вариант реализовывал так. 
    # Только без фильтрации - она у меня так и не заработала.
'''
вызвать данные в шаблоне можно обратившись к ним как baskets.0.<имя_метода>
костыль конечно - но более менее работает... чтото более умное в голову не пришло. 
да и этот вариант до конца не реализовал.
'''

    #Почему-то кажется, что не в ту сторону вообще 
    # ковыряю. задание со звездочкой и оно решается через контроллер в 
    # принципе достаточно адекватно и фильтрация там работает на «5»
    
    @classmethod
    def total_quantity(cls): # cls вместо self чтобы не путаться
        res  = cls.objects.all().aggregate(Sum('quantity')) 
        return res['quantity__sum']        
    
    @classmethod
    def total_sum(cls):
        data = cls.objects.all() # пробовал тут использовать filter, но не пошло.
        res=0
        for i in data:
            res+=i.sum()
        return res

```

закоммитил и отправил преподавателю... 

> в ответ получил информацию о том что данный метод хорош,но есть способ проще и лучше) и что на следующем занятии его мне покажут ))) будем посмотреть.
По результату ответа и очередного разбора домашнего задания понял, что наилучший (причем наиочесиднейший) способ получения указанных значений - итерация по корзинам во вьюшке и подсчет с последующей передачей значения в контроллере как колнтекст формы.

```python
baskets = Basket.objects.filter(user=user)
total_quantity = sum(basket.quantity for basket in baskets)
total_summ = sum(basket.sum for basket in baskets) # 'это тот sum который сделан в 6 задании!
```
Это если делать через контроллер. а если делать через модель - то будет так:


### 8*. Добавить обработку ошибок для страницы профиля (личного кабинета). И добавить сообщения об успешних действиях. 

Вывод информационного сообщения сделал еще в задании 2, а ошибки, которые могут возникнуть на странице профайла что-то в голову не приходят, поэтому я их и не сделал...

## Урок 6 «Корзина + AJAX + декораторы»
### 1. Добавить к модели корзины методы `total_sum,()` и `total_quantity()` и вывести в меню количество товара и их полную стоимость.

Поскольку вызов в шаблоне у еня сдалн правильно, то изменб код в модели на :
```python
    def total_quantity(self): 
        baskets = Basket.objects.filter(user=self.user)
        return sum(basket.quantity for basket in baskets)      
    
    def total_sum(self):
        baskets = Basket.objects.filter(user=self.user)
        return sum(basket.sum() for basket in baskets)
```
для того чтобы это было еще красивей, пропишу общее этих двух функций в декоратор.
```python
    @property
    def baskets(self):
        return Basket.objects.filter(user=self.user)
            
    def total_quantity(self):
        return sum(basket.quantity for basket in self.baskets)  # baskets, который property    
    
    def total_sum(self):
        return sum(basket.sum() for basket in self.baskets) # baskets, который property    
```
действительно - гораздо проще и красивей.
проверил, закоммитил.

### 2. Защитить доступ к корзине и личному кабинету декоратором @login_required.

Чтобы использовать этот декоратор, один из стандартных для Django, нужно его импортировать и прописать его вызов каждый раз, когда вызываются **ЛЮБЫЕ** контроллеры, где необходима авторизация.  Если этого не сделать, то там, где это не сделано будет вываливаться ошибка рендеринга. Внастоящий момент таких мест три (два в контроллере корзины, и один в контроллере профайла) код на примере контроллера корзины:
```python
from django.shortcuts import render, HttpResponseRedirect
from products.models import Products
from baskets.models import Basket
from django.contrib.auth.decorators import login_required

@login_required
def basket_add(request, product_id):
    product = Products.objects.get(id=product_id) # взяли нужный продукт (с которого на кнопку нажали)
    baskets = Basket.objects.filter(user = request.user, product=product) 
    # отфильтровали корзину по нужному продукту и пользователю
    # если есть - то нужно +=1, если нет, то нужно создать 1
    if not baskets.exists():
        Basket.objects.create(user = request.user, product = product, quantity = 1) # создали запись в корзине на 1 единицу товара
        return HttpResponseRedirect(request.META.get('HTTP_REFERER')) # вернулись туда откуда пришли
    else:    
        basket = baskets.first() # взяли любой, потому что первый - он и последний.
        basket.quantity+=1 # +=1..
        basket.save() # сохранили изменение количества
        return HttpResponseRedirect(request.META.get('HTTP_REFERER')) # вернулись туда откуда пришли

@login_required
def basket_remove(request, id): #здесь id это id корзины а не товара.
    basket = Basket.objects.get(id=id)
    basket.delete()
    return HttpResponseRedirect(request.META.get('HTTP_REFERER'))
    
```
Кроме того, нужно прописать в settings.py глобальную константу, от которой зависим этот декоратор.
```
LOGIN_URL = '/users/login/'
```
проверяю, комичу... 

### 3. Реализовать асинхронное редактирование количества товаров в корзине при помощи AJAX.

AJAX засчет асинхронности позволяет выполнять процессы не последовательно (методом FIFO) а с определенной долей параллельности (асинхронно - это не параллельно, а именно асинхронно, см. понятие асинхронности…), что позволяет существенно ускорить обработку задач, послыаемых на сервер, поскольку не происходит постоянной перезагрузки страниц, а когда нужно страница обновляется частично, только в рамках загруженного ответа. AJAX работает не на JS, а на JQuery.
(Действую по образцу, ибо несколько «плаваю» в джаве»)
1. Меняю шаблон, создавая на основе страницы блок (div) с классом, который потом будет использовать в скрипте (это нужно, чтобы обращаться ко всеу блоку целиком):
```html
<div class = "basket_list">
    {%if baskets%}
    <div class="col-lg-5">
        <h4 class="mt-3 mb-3 d-flex justify-content-between align-items-center mb-3">
            Корзина <span class="badge badge-secondary badge-pill">{{baskets.0.total_quantity}}</span>
    <!--
            исправить общее количесвто
    -->
        </h4>
        <div class="card mb-3">
            {%for basket in baskets%}
                <div class="card-body">
                    <h5 class="card-title">{{basket.product.name}}</h5>
                    <p class="card-text">{{basket.product.description}}</p>
                </div>
                <ul class="list-group list-group-flush">
                    <li class="list-group-item bg-light">
                        <div class="row text-center">
                            <div class="col-lg-4">
                                <input name="basketID" type="number" class="form-control"
                                       value="{{basket.quantity}}" min="0">
                            </div>
                            <div class="col-lg-4">{{basket.sum}}</div>
                            <div class="col-lg-4">
                                <a href="{% url 'baskets:basket_remove' basket.id %}">
                                    <i class="fas fa-trash"></i>
                                </a>
                            </div>
                        </div>
                    </li>
                </ul> 
            {%endfor%}
        </div>
        <div class="card mb-3">
            <div class="card-footer">
                <p class="float-left">Итого</p>
                <h4 class="float-right">{{baskets.0.total_sum}} руб.</h4>
    <!--
                исправить общий подсчтет стоимости
    -->
            </div>
        </div>
        <button type="button" class="btn btn-success btn-lg float-right">Оформить</button>
    </div>
    {%else%}
        <h4 class="mt-3 mb-3">
            Корзина пуста
            <!-- не стал делать по центру -->
        </h4>
    {%endif%}
    
</div>
```
2. Пишу скрипт, который будет работать с корзиной
```javascript
window.onload = function () {
    $('.basket_list').on('click', 'input[type="number"]', function () {
        let t_href = event.target;
        // console.log(t_href.name); // идентификатор корзины
        // console.log(t_href.value); // количество в корзине (актуальное)

        $.ajax({
            url: '/baskets/edit/' + t_href.name + '/' + t_href.value + '/', // Этот адрес важен!
            success: function (data) {
                $('.basket_list').html(data.result);
            }
        });

        event.preventDefault();
    })
}
```
3. изменяю шаблон в точке, где происходит редактирвоание количества товара в данной корзине.
```html
<input name="{{ basket.id }}" type="number" class="form-control"
    value="{{ basket.quantity }}" min="0">
```
4. подключаю скрипт в базовый шаблон из которого просходит формирование страницы (в products)
```html
<script src="{% static 'js/basket.js'%}"></script>
```
5. теперь пишу контроллер и подключаю его в urls корзины
```python
@login_required
def basket_edit(request, id, quantity):
    """
    тут в контроллер передается собственно запрос, который содержит общие данные, идентификатор корзины которую нужно изменить, новое актуальное количество, которое нужно записать в корзину. а сумма считается при выводе через контроллер или ч/з модель (у меня модель)
    """
    if request.is_ajax():                       # запрос пришел от ajax
        basket = Basket.objects.get(id=id)      # выбрали корзину с нужным id
        if quantity>0:                          # если актуальное количесвто > 0 - перепишем корзину
            basket.quantity = quantity
            basket.save()
        else:                                   # если 0 или меньше - удалим корзину
            basket.delete()
        # корзина изменена, теперь ее нужно «показать», возвратив ответ.
        # дял этого делаем то-же что и в контроллере, но дял «кусочка» страницы, которую нужно обновить.
        baskets = Basket.objects.filter(user = request.user)            # берем все корзины пользователя
        context = {'baskets': baskets}                                  # формируем контекст
        result = render_to_string('baskets/basket.html', context)       # рендерим
        return JsonResponse({'result': result})                         # возвращаем рез-т
```
urls.py
```python
urlpatterns = [
    path('add/<int:product_id>/', basket_add, name = 'basket_add'),
    path('remove/<int:id>/', basket_remove, name = 'basket_remove'),
    # контроллер редактирования корзины по идентификатору и количеству.
    # !!! важно чтобы адрес совпадал с адресом (тем как он формируется) из скрипта !!!
    path('edit/<int:id>/<int:quantity>/', basket_edit, name = 'basket_edit'),
]
```

> когда больше трех товаров шаблон «плывет» как при ресайзе.

после проведенных манипуляций состав корзины редактируется в рамках реализованной логики

проверяю. комичу.

## Урок 7 «Собственная админка»1. 

### 1. Создать приложение админки и интегрировать его в проект.

Приложение добавляем командой
```bash
python manage.py startapp admins
```
подключаем его в INSTALLED_APPS в settings.py
название приложения «admins» выбрали потому, что «admin» в проекте есть по умолчанию.
проверяю чтобы приложение создалось и коммичу.

### 2. Реализовать механизм CRUD админки на выбор: пользователи, продукты, категории.
Поскольку основной функционал в нашем проекте основан на товарах, то в первую очередь подключать хотел товары... но дял товаров небыло шаблона страницы, поэтому побоялся запутаться и пошол по пути предложенном преподавателем. А именно - стал подключать пользователей. Поэтому буду по системе CRUD первыми делать пользователей. Позже, пока будут проверять и мержить ветку - возможно подключу остальные...
(код по частям раздела не дописываю, поскольку все то что здесь делается - является закреплением ранее пройденного материала)
CRUD - (Create, Read, Update, Delete) - аббревиатура означающая принцип использования модели в Джанго.
дял того, чтобы ее реализовать, нужно:
 - 4 страницы (а посути - шаблона)
 - 4 контроллера (дял каждого действия)
 - +1 контроллер дял отображения главной страници товаров.
Поскольку страницы должны иметь стандартный вид, то необходимо чтобы они все были наследованы из базового шаблона, т.е нужно иметь этот шаблон.
**Поэтому в первую очередь создадим этот базовый шаблон** и сделаем на его основе 4 шаблона для системы CRUD. однако тут момент такой - можно обновление и удаление объединить в один шаблон, поэтому делать будем на самом деле базовый +3 (для добавления, для чтения, и дял обновления/удаления)
**Во вторую - дял каждого шаблона - по контроллеру**  
**В третью - создадим пространство имен дял «admins»  
**В четвертую - подключим пространство в urls.py всего проекта**  
**В пятую - в шаблонах страниц поменять местные ссылки**, которые остались от визуального редактора на ссылки из пространства имен, вида 'admins:…', прописанные в admins/urls.py
На этом страницы созданы и осталось каждую из них наполнить логикой. они работают, открываются и показываются -  
**делаю промежуточный коммит.
далее займусь наполнением функционалом каждой страницы.
1. первым изменю контроллер отображения пользователей (admin_users), и соответсвующий ему шаблон. (Единственное НО - тут в шаблоне проверяются пользователи is_staff, но на суперпользовательность их проверять не нужно, поскольку суперпользователи входят в тех, кто имеет право заходить в консоль). **Коммичу на этом этапе.**
2. добавляю логику добавления пользователя (контроллер admin_users_create и соответсвующий ему шаблон). Та-же задача решалась при регистрации... поэтому можно делать аналогично, а можно использовать форму регистрации, в которую добавить ввод картинки.
Для этого создаем форму, но наследуем ее от users.RegistrationForm:
```python
from django import forms;
from users.forms import UserRegistrationForm
from users.models import Users

class AdminsUserCreationForm(UserRegistrationForm):
    # все стили уже определены в предке, кроме 
    image = forms.ImageField(widget=forms.FileInput(attrs={'class': 'custom-file-input'}), required=False)
    
    class Meta:
        model = Users
        fields = (
            'username', 
            'email', 
            'image',
            'first_name', 
            'last_name', 
            'password1', 
            'password2', 
            )
```
изменяем контроллер:
```python
# Добавление пользователя
def admin_users_create(request):
    if request.method == 'POST':
        form=AdminsUserCreationForm(data=request.POST, files = request.FILES) # Важный момент с передачей фала!
        if form.is_valid():
            form.save()
            # сообщение не нужно, поскольку в случае успеха мы перейдем на страницу с перечнем пользователей
            return HttpResponseRedirect(reverse('admins:admin_users'))
        else:
            print(form.errors) # это мы вывели ошибки валидации формы в отладке
    else:
        form = AdminsUserCreationForm()
    
    context = {
        'title': 'GeekShop - Новый пользователь',
        'form': form,
    }
    return render(request, 'admins/admin-users-create.html', context)
```
изменяем шаблон:
```html
{% extends 'admins/base_template.html'%} {% load static %}

{% block content %}
    <main>
        <div class="container-fluid">
            <h1 class="mt-4">Создание пользователя</h1>
            <form action="{% url 'admins:admin_users_create' %}" method="post" enctype="multipart/form-data">
                {% csrf_token %}
                <div class="form-row">
                    <div class="col-lg-6">
                        <div class="form-group">
                            <label class="small mb-1" for="{{ form.first_name.id_for_label }}">Имя</label>
                            {{form.first_name}}
                        </div>
                    </div>
                    <div class="col-lg-6">
                        <div class="form-group">
                            <label class="small mb-1" for="{{ form.last_name.id_for_label }}">Фамилия</label>
                            {{form.last_name}}
                        </div>
                    </div>
                </div>
                <div class="form-row mb-2">
                    <div class="col-lg-12">
                        <div class="custom-file">
                            {{ form.image }}
                            <label class="custom-file-label" for="{{ form.image.id_for_label }}">
                                Выберите изображение
                            </label>
                        </div>   
                    </div>
                </div>
                <div class="form-row">
                    <div class="col-lg-6">
                        <label class="small mb-1" for="{{ form.username.id_for_label }}">Имя пользователя</label>
                        {{form.username}}
                    </div>
                    <div class="col-lg-6">
                        <label class="small mb-1" for="{{ form.email.id_for_label }}">Адрес электронной
                            почты</label>
                        {{form.email}}
                    </div>
                </div>
                <div class="form-row">
                    <div class="col-lg-6">
                        <label class="small mb-1" for="{{ form.password1.id_for_label }}">Пароль</label>
                        {{form.password1}}
                    </div>
                    <div class="col-lg-6">
                        <label class="small mb-1" for="{{ form.password2.id_for_label }}">Повторите пароль</label>
                        {{form.password2}}
                    </div>
                </div>
                <div class="form-row">
                    <div class="col-lg-12" style="margin-top: 33px;">
                        <input class="btn btn-info btn-block" type="submit" value="Сохранить">
                    </div>
                </div>
            </form>
        </div>
    </main>
{%endblock%}
```
Важный момент! - в параметрах формы в шаблоне нужно обязательно указать:
```html
<form action="{% url 'admins:admin_users_create' %}" method="post" enctype="multipart/form-data">
```
иначе не будет сохраняться картинка при сохранении пользователя  
**проверил и промежуточно закоммитил**  
3. Делая обновление и удаление пользователя имеет смысл разделить это действие на два контроллера. Пурвый будет обновлять, а второй удалять. Соответсвенно эти два контроллера нужно прописать в urls пространства адресов приложения.
Если поменять ссылку в шаблоне при выводе пользователя на:
```html
<a href={% url 'admins:admin_users_update' user.id %} style="color: dodgerblue">{{user.username}}</a></td>
```
, то будет показываться страница редактирвоания данных пользователя.
теперь нужно сделать:
- форму для страницы редактирвоания (наследуя ее аналогично от профайла)
```python
 class AdminUserUpdateForm(UserProfileForm):
    # класс Meta переопределять не нужно - оопределен в профиле, который родитель
    # но нужно переопределить доступные только для чтения поля:
    username = forms.CharField(widget=forms.TextInput(attrs={'class': 'form-control py-4'}))
    email    = forms.CharField(widget=forms.EmailInput(attrs={'class': 'form-control py-4'}))
```
 - контролллер 
```python
# Изменение пользователя
def admin_users_update(request, pk):
    selected_user = Users.objects.get(id=pk) 
    # это тот пользователь на которого кликнули по ссылке на странице пользователей админки
    if request.method == 'POST':
        form = AdminsUserUpdateForm(instance = selected_user, data = request.POST) # сказали что менять будем у этого пользователя, которого выбрали на странице
        if form.is_valid(): 
            form.save()
            return HttpResponseRedirect(reverse('admins:admin_users'))
    else:
        form = AdminsUserUpdateForm(instance=selected_user) # передали текущего пользователя для отображания его «ТТХ» через GET запрос
    context = {
        'title': 'GeekShop - Изменение профиля пользователя',
        'form': form,
        'selected_user': selected_user,
    }
    return render(request, 'admins/admin-users-update-delete.html', context) 
```
назначить адреса в пространство (urls.py)
```python
urlpatterns = [
    path('', index, name = 'index'),
    path('users/', admin_users, name = 'admin_users'),
    path('users-create/', admin_users_create, name = 'admin_users_create'),
    path('users-update/<int:pk>/', admin_users_update, name = 'admin_users_update'),
    path('users-delete/<int:pk>/', admin_users_delete, name = 'admin_users_delete'),
]
```
код шаблона
```html
<main>
    <div class="container-fluid">
        <h1 class="mt-4">Редактирование пользователя | {{selected_user.username}}</h1>
        <div class="card-body">
            <form action="{% url 'admins:admin_users_update' selected_user.id%}" method="POST" >
                {% csrf_token %}
                <div class="form-row">
                    <div class="col-lg-6">
                        <div class="form-group">
                            <label class="small mb-1" for="inputFirstName">Имя</label>
                            {{form.first_name}}
                        </div>
                    </div>
                    <div class="col-lg-6">
                        <div class="form-group">
                            <label class="small mb-1" for="inputLastName">Фамилия</label>
                            {{form.last_name}}
                        </div>
                    </div>
                </div>
                <div class="form-row mb-2">
                    <div class="col-lg-12">
                        <div class="custom-file">
                            {{form.image}}
                            <label class="custom-file-label" for="userAvatar">Выберите изображение</label>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="col-lg-6">
                        <label class="small mb-1" for="inputUsername">Имя пользователя</label>
                        {{form.username}}
                    </div>
                    <div class="col-lg-6">
                        <label class="small mb-1" for="inputEmailAddress">Адрес электронной
                            почты</label>
                        {{form.email}}
                    </div>
                </div>
                <div class="form-row">
                    <div class="col-lg-12" style="margin-top: 33px;">
                        <input class="btn btn-info btn-block" type="submit" value="Сохранить">
                    </div>
                </div>
            </form>
            <div class="row">
                <div class="col-lg-12" style="margin-top: 33px;">
                        <a>Удалить</a>
                </div>
            </div>
        </div>
    </div>
</main>
```

4. Удаление пользователя...
контроллер
```python
#удаление пользователя    
def admin_users_delete(request, pk):
    selected_user = Users.objects.get(id=pk) 
    selected_user.delete()
    return HttpResponseRedirect(reverse('admins:admin_users'))
```
шаблон
```html
<a class="btn btn-danger btn-block" href = "{% url 'admins:admin_users_delete' selected_user.id %}" >Удалить</a>
```
НО ТУТ ТАКОЙ МОМЕНТ……
если пользователя удалить таким образом - то его не станет в БД вообще... а это не есть хорошо. Часто информация по пользователю нужна в последствии, поэтому при удалении пользователя переводят в статус «неактивен» (is_active=false, но это — задание 4, смотреть туда...)

### 3. Защитить доступ к админке декоратором @user_passes_test.
для того чтобы сделать указанное, нужно перед каждым вызовом контроллера (каждого) в модуле admins/views.py добавить вызов декоратора
```python
@user_passes_test(lambda u: u.is_staff)
```
в который как параметр будет передаваться рузультат выполнения лямбда-функции валидной, когда пользователь из числа имеющийх доступ к админке (staff)
**тогда**  
будет логически правильно, чтобы у пользователей, которые не имеют права на админку даже не показывалась иконка для перехода на нее на всех страницах сайта. Для этого достаточно отредактировать шаблон bases_template из products:
```html
{% if user.is_staff %}    
<a class="nav-link" href="{%url 'admins:index'%}">
    <i class="fas fa-users-cog"></i>
</a>
{% endif %}
```

### 4. Реализовать удаление через свойство is_active.
поскольку физически удалять пользователя из БД не правильно, то его можно деактивировать.
```python
def admin_users_delete(request, pk):
    selected_user = Users.objects.get(id=pk) 
    #selected_user.delete() # физическое удаление пользователя из БД. 
    selected_user.is_active=False
    selected_user.save()
    return HttpResponseRedirect(reverse('admins:admin_users'))
```
проверил, закоммитил

### 5*. Преобразовать админку Django (так же на выбор: пользователи, продукты, категории или корзина).
в первую очередь имеет смысл довести до ума работу с пользователями, раз уж начали делать именно это... к тому-же в планах сделать нормальную админку дял управления товарами и категориями, а управленеи пользователями (за исключением активации и деактивации, а также принудительного заведения) оставить для суперюзеров, то есть дать возможность делать с ними все, что нужно через стандартную админку.
Модификация админки под удобный вывод модели делается в admin.py приложения, в котором аходится модель
```python

#admin.site.register(Users) # если оставить, то не даст модифицировать вывод через класс

#модификация стандартной админки
@admin.register(Users)
class UserAdmin(admin.ModelAdmin):
    # табличный вывод (как каталога)
    list_display=('username', 'first_name','last_name', 'email','is_staff', 'is_active', 'is_superuser')
    # сортировка (каталога) - но ее понятней выплнить интерактивно
    ordering = ('-is_superuser', '-is_staff', '-is_active', 'username',)
    # фильтрация (каталога) - ищет вхождение ключа в заданных полях.
    search_fields = ('username', 'first_name', 'last_name', 'email')
    
    
    # отображение «карточки» элемента «справочника» 
    # кортеж в кортеже - группировка
    fields = (('username', 'email'),('is_staff', 'is_active', 'is_superuser'),('first_name','last_name'), 'image', 'password')
    # поля доступные только дял чтения
    readonly_fields = () # ничего не ввел... ибо нечего ридонлить
```
аналогичным образом «поправил» остальные модели...
проверил.. закоммитил…

Дополнительно (1, 2, 3)
Сделал админку для: 
 - категорий товаров
 - товаров
и заменил укнопку «удалить» в пользователях на «деактивировать/активировать»
код не добавляю, итак все понятно.



##  Урок 8 «Полезное: страничный вывод, шаблонные фильтры, CBV»

### 1. Организовать фильтрацию продуктов по категориям.
Для того, чтобы это сделать нужно изменить контроллер, шаблон и пространство адресов.
контроллер примет вид:
```python
def products(request, category_id=None):
    import datetime
    from products.models import Products, ProductsCategory
    
    if category_id:
        products_filter = Products.objects.filter(category_id=category_id) # фильтруем по идентификатору внутри справочника категорий по значению category_id, которое пришло из переменных вызова функции.
    else:
        products_filter = Products.objects.all()    
    
    context = {
            'title': 'GeekShop - каталог наших предложений',
            'date': datetime.datetime.now().today(),
            'products': products_filter,
            'category': ProductsCategory.objects.all()
        }
    return render(request, 'products/products.html', context)
```
пространство адресов:
```python
urlpatterns = [
    path('',products, name = 'index'), # но это уже index не от сайта а от пространства адресов products
    path('<int:category_id>',products, name = 'category') # адрес будет ../category/<id>
]
```
а часть шаблона, отвечающая за показ перечня категорий :
```html
{%for cat in category%}
<div class="list-group">
    <a href="{% url 'products:category' cat.id %}" class="list-group-item">{{cat.name}}</a>
</div>
{%endfor%}
```
проверил, закоммитил.

### 2. Организовать постраничный вывод в каталоге (пагинацию).
В джанго встроен класс пагинации, который называется pagination, если поуглить то можно получить исчерпывающий ответ на тему того, что он делает и какие у него методы.
В связи с его применением код изменится следующим образом:
контроллер
```python
def products(request, category_id=None, page=1):
    import datetime
    from products.models import Products, ProductsCategory
    
    if category_id:
        products_filter = Products.objects.filter(category_id=category_id) 
            # фильтруем по идентификатору внутри справочника категорий 
            # по значению category_id, которое пришло из переменных вызова функции.
    else:
        products_filter = Products.objects.all()    
    paginator = Paginator(products_filter, 6) # где число - это количесвто товаров на странице
        # создали пагинатор
    try:
        products_paginator = paginator.page(page)
            # получили список товаров на странице page
    except PageNotInteger:
        products_paginator = paginator.page(1)
                # отобразим первую страницу
    except EmptyPage:
        products_paginator = paginator.page(pagintor.num_pages())
                # отобразим вообще все товары
    context = {
            'title': 'GeekShop - каталог наших предложений',
            'date': datetime.datetime.now().today(),
            'products': products_paginator,  # Заменили фильтр на пагинатор
            'category': ProductsCategory.objects.all()
        }
    return render(request, 'products/products.html', context)
```
пространство адресов для products
```python
urlpatterns = [
    path('',products, name = 'index'), # но это уже index не от сайта а от пространства адресов products
    path('<int:category_id>/',products, name = 'category'), # адрес будет ../category/<id> 
    path('page/<int:page>/',products, name = 'page'), 
]
```
часть шаблона products которая отвечает за пагинатор
```html
<nav aria-label="Page navigation example">
    <ul class="pagination justify-content-center">
        <li class="page-item {% if not products.has_previous %} disabled {%endif%}">
            <a class="page-link" 
                href="{% if products.has_previous%} {% url 'products:page' products.previous_page_number%} {% else %} # {%endif%}" 
                tabindex="-1" aria-disabled="true">
                Предыдущая
            </a>
        </li>
        {% for page in products.paginator.page_range %}
            <li class="page-item">
                <a class="page-link" href="{% url 'products:page' page %}">
                    {{page}}
                </a>
            
            </li>
        {%endfor%}
        <li class="page-item {% if not products.has_next %} disabled {%endif%}">
            <a class="page-link" 
                href="{% if products.has_next%} {% url 'products:page' products.next_page_number%} 
                {% else %} # {%endif%}">
                Следующая</a>
        </li>
    </ul>
</nav>
```



### 3. Перевести как можно больше контроллеров в проекте на CBV.
Эту часть домашнего задания довел до подключения двух видов контроллеров - на создание и на чтение (без изменения данных). Поскольку задание обязательное, а я его не выполнил - то сдавать его не буду, и как результат не получу свои 10 последних баллов ((( . В любом случае, я знаю что большую часть курса прошол и сделал это хорошо.

Осталось разбираться во многих вещах, но я так мыслю что теперь это сделать станет гораздо проще. Поскольку дальнейшая учеба на этом курсе у меня, скорее всего, не получится, то думаю что достаточно многого достиг. 

Дальше этот проект будет развиваться, но уже в другой плоскости + я на его основе стану изучать джанго самостоятельно.

Подробно о том, что есть CBV в конце обобщающего докуентального файла.


___
## Приложения и выводы

### Логика проектов django
**Ну вопервых** - джанго это фреймворк только для веб-разработки. Причем крайне быстрой и крайне простой (всего лишь один из многих - но остальные сущестенно сложнее). Для работы проекта локально — нужен веб-сервер. В комплекте поставки джанго есть простой сервер - но он отладочный и работает **только** локально (т.е даже в рамках одной сети его использовать не получится?). Для того, чтобы получить что-то большее, нужно использовать адекватный веб-сервер с апачем и всем что там пожет пригодиться (н-р NGINX).
**Во вторых**: в составе джанги по умолчанию используются базы sqlite3 но они легко могут быть заменены на любой sql движок - напримор постгрис.
**В третьих**: Проект - это вся веб аппликация целиком, как она видна в браузете на главной странице. **НО ЭТОТ ПРОЕКТ ВКЛЮЧАЕТ В СЕБЯ ПРИЛОЖЕНИЯ, КОТОРЫЕ ЯВЛЯЮСЯ ЕГО ЗАКОНЧЕННЫМИ МОДУЛЯМИ** Эти приложения находятся в папке с проектом в отдельных папках. Структура всех приложений - одинаковая. Более того, по умолчанию в любом созданом проекте есть несколько проектов. Первый - это сам проект, а точнее его главное приложение (его папка с таким же именем находится в папке проекта ~ geekshop/geekshop): в нем находятся урлы, сеттинги и многое другое. Второй - предустановленная админка, но она не находится в самом проекте, а дается глобально из модулей джанги. если админку переделывать, то ее отключают и подключают свое приложение админки. есть и еще приложения, которые по умолчанию подключаются к проекту, их состав зависит от версии джанги.  
…



### Коды ответов сервера

1. Информационные 100 - 199
2. Успешные 200 - 299
3. Перенаправления 300 - 399
4. Клиентские ошибки 400 - 499
5. Серверные ошибки 500 - 599

### Главное о GIT

- Когда есть репозиторий, то получить его актуальное состояние на коммит можно командой 
```
git checkout <коммит>
```
при этом ресета не происходит.

- если возникли какие-то ошибки, то проще перегрузить последний репозиторий полностью

- когда неправильно сделан последний комит, и он (ни дай Бог, выгружен в глобальный реп) и его нужно вообще удалить, то делается это так:

```
git reset --hard <предпоследний коммит>
git push --force
```
- когда нужно получить состояние репозитория на коммит, в виде отдельного каталога с репозиторием - можно прибегнуть к команде git export … (см документацию)
- если нужно изменить последнйи комит:
```
git commit --amend -m "новый комментарий"
```
так можно изменить не только коммент, но и файлы комита, если их предварительно добвить командой add
- если создана новая ветка - то при первом пуше на нее гит ругнется и тутже покажет методу решения.
- увидеть изменения внесенные последним коммитом, можно набрав 
```bash
git show
```
а на произвольный коммит 
```bash
git show <commit>
```

### Последовательность действий при создании приложения

```
python manage.py startapp <название приложения>
+ прописать в installed_aps который в settings.py 
```

### Работа с шаблонами и динамические страницы

во общем дело такое. В контроллере формируется переменная context, которая представляет собой итерируемый справочник вида:

```
context = {
	'переменная': <значение>,
	…
}
```

в этом справочнике может быть любая вложенность, которую только может захотеть программист, в том числе и вида

```python
 context = {
        'title': 'GeekShop',
        'header': 'Добро пожаловать на сайт!',
        'username': 'Иван Иванов',
        'products': [
            {'name': 'Худи черного цвета с монограммами adidas Originals', 'price': 6090},
            {'name': 'Синяя куртка The North Face', 'price': 23725},
            {'name': 'Коричневый спортивный oversized-топ ASOS DESIGN', 'price': 3390},
        ],
        'promotion': False, # предполагается что это значение будет читаться откуда-то из космоса…
        'products_of_promotion': [
            {'name': 'Черный рюкзак Nike Heritage', 'price': 2340},
        ]
    }
```

тогда при обращении к элементам вложенных итеритуемых объектов это нужно учитывать.

передача контекста фомируемой страници делается в процедуре render контроллера:

```
return render(request, 'products/test-context.html', context)
```

Страница будет формироваться по шаблону:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ title }}</title>
</head>
<body>
<h1>{{ header }}</h1>
<p>{{ username }}</p>
<h3>Ваши товары:</h3>
{% for product in products %}
    <h4>Навзание: {{ product.name }}</h4>
    <p>Цена: {{ product.price }} руб.</p>
{% endfor %}
{% if promotion %}
    <h3 style="color: red;">Акция:</h3>
    {% for product in products_of_promotion %}
        <h4>Навзание: {{ product.name }}</h4>
        <p>Цена: {{ product.price }} руб.</p>
    {% endfor %}
{% endif %}
</body>
</html>
```

тут:

```
{{…}} - это плэйсхолдер
{%…%} - это шаблонный тэг
```

первые - это простой вызов переменной из контекста, поскольку это строковое значение в контексте, то чисто теоретически оно должно указываться в скобках, **но этого делать не нужно** поскольку шаблон понимает простое обращение как к переменной.

вторые - это когда нужно что-то проитерировать или другим образом поработать с каким либо оператором. Применять другие методы можно, но с оглядкой, покольку их может не быть среди известных шабону методов - и вообще данные в шаблон лучше всего сразу засылать в готовом виде, поскорльку их в нем не нужно будет обрабатывать и они просто отобразятся. пример другого шаблонно тэга

```html
{% comment "Optional note" %}
    <p>Commented out text with {{ create_date|date:"c" }}</p>
{% endcomment %}
```

если данные нужно всетаки как-то конвертировать или форматировать, то применяют **шаблонные фильтры**

По сути шаблонный фильтр — это просто функция, написанная на Python, которая возвращает
измененные данные в точку вызова. В конце курса напишем собственные шаблонные фильтры.
Пример шаблонного фильтра title, преобразующего первую букву слова в заглавную:

```html
{{ user.first_name|title }}
```

шаблонных фильтров не просто много, а пипец как много. Они перечислены тут:

[https://docs.djangoproject.com/en/2.1/ref/templates/builtins/](https://docs.djangoproject.com/en/2.1/ref/templates/builtins/)

например вызов фильтра комментария будет следующим:

```html
{% comment "Optional note" %}
    <p>Commented out text with {{ create_date|date:"c" }}</p>
{% endcomment %}
```



### Последовательность действий при создании страниц для приложения 

(см домашку 1 и немножечко 2):

1. создать приложение, при необходимости создать модели для приложения
2. в приложении создать templates/<имя приложения>
3. в нем создать шаблоны (базовый + шаблоны всех страниц, которые будут у приложения)
>однако это можно сделать в конце, после того, как подключен контроллер

4. создать контроллер (views) для страниц, и сформировать передаваемый контекст
5. прописать созданные страницы в urls (тот что в главном приложении)
6. если предусмотрен переход на страницы приложения из других приложений (или главной страницы проекта, находящейся в другом приложении) исправить (прописать) ссылки на страницы нового приложения в шаблонах этих приложений.

### Последовательность действий при создании форм ввода для приложений (на примере авторизации)
> Есть два вида запросов (на самом деле больше, но эти нужны сейчас), GET и POST - первый получает данные от сервера, второй отправляет данные на сервер. (подробней в методичке). сперва срабатывает Get, потом - POST. Первый - это безопасный (или условно безопасный) запрос предназначенный только для **вывода** данных в форму. Он выполняется **всегда**. Второй - небезопасный, предназначенный для пеердачи данных от пользователя на сервер. он отрабатывает только тогда, когда для этого есть прямое указание (см. код)
логика такая: сперва вьюшка показывает страницу - она отрабатывает запрос GET, при котором формируется контекст и выводятся данные. Если страница вывелась и пользователь ввел в нее что-то, то формируется (если на это прямо указано в HTML коде) запрос POST, который и передает данные на сервер (снова во вьюшку, где они и обрабатываются). Поскольку POST запрос небезопасный - то данные нужно отправлять при помощи токена (см код)
теперь как это в коде:
1. Создали форму - специальный объект, предназначенный для взаимодействия с HTML формами (теми что описаны в теге <form>). для этого создаем forms.py в корне приложения и в него записываем код:
```python
   from django.contrib.auth.forms import AuthenticationForm
   from users.models import Users

class UserLoginForm(AuthenticationForm):
    class Meta: # это метакласс
        model = Users
        fields = ('username', 'password')
```
от авторизации нужен только логин и пароль - поэтому их и используем. 
2. Создали вьюшку, в которой использовали созданную ранее форму:

```python
from django.shortcuts import render, HttpResponseRedirect
from users.forms import UserLoginForm
from django.contrib import auth
from django.urls import reverse

def login (request):  # это POST запрос на обработку данных
    if request.method == 'POST':
        form = UserLoginForm(data=request.POST)
        if form.is_valid(): # если данные в форме валидны (а данные тут - кусок html кода)
            username = request.POST['username']
            password = request.POST['password']
            user = auth.authenticate(username=username, password=password) # результат прохождения аутентификации
            if user and user.is_active:
                auth.login(request, user) # авторизоваться этим пользователем
                return HttpResponseRedirect(reverse('index')) # перенаправить на главную
    else:
        form = UserLoginForm()
    

    # это стандартный GET запрос
    context = {
        'title': 'Авторизация в GeekShop',
        'form': form,
    }
    return render(request, 'users/login.html', context)
```
3. Нарисовали форму в шаблоне html (или исправили его)
```html
<form action="{% url 'users:login' %}" method = "post">
    {% csrf_token %}
    {{form.as_p}}
<!--выше прописана обязательная часть кода, которая пришла из HTML! 
она говорит, что данные передались в контроллер страницы «логин», 
где они и будут обрабатываться -->
</form>
```
но в данном случае html код **исключительно минимален**, чтобы понять логику.
> - поскольку мы обрабатываем в данном случае только POST запрос, то в HTML прямо и указываем «method="post"»
> - поскольку POST запрос небезопасный, то сним работат можно только используя токен, дял этого мы в теле формы на HTML написали {% csrf_token %}
> - поскольку форма - это html код то его можно представить как абзац (тег <p>) и вывести. в этом абзаце содержится сейчас поле ввода логина и пароля, сгенерированное джангой.

Если на этом этапе нажать на кнопку, которая «submit», то при правильном логине и пароле произойдет сперва аутентификация, а потом авторизация.  
Но полученная форма (которую видит пользователь) — крайне некрасивая, поэтому наведем порядок с ее отображением:
```html
<form action="{% url 'users:login' %}" method="post">
{% csrf_token %}
<div class="form-group">
    <label class="small mb-1" for="{{ form.username.id_for_label }}">Имя
        пользователя</label>
    {{ form.username }}
</div>
<div class="form-group">
    <label class="small mb-1" for="{{ form.password.id_for_label }}">Пароль</label>
    {{ form.password }}
</div>
<div class="form-group d-flex align-items-center justify-content-between mt-4 mb-0">
    <a class="small" href="#">Забыли пароль?</a>
    <input class="btn btn-primary" type="submit" value="Авторизоваться">
</div>
</form>
```
а поскольку мы добавили уже готовые элементы кода в частях {{ form.password }} и {{ form.username }}, нужно чтобы они отображались в соответсвии со стилем, который задан в CSS... а для этого нужно снова исправить форму (в forms.py, где они формируются) и она примет вид:
```python
class UserLoginForm(AuthenticationForm):
    form django import forms
    # это для соответсвия передаваемых кусков кода стилям, прописанным в CSS
    username = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите имя пользователя'}))
    password = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4', 'placeholder': 'Введите пароль'}))

    class Meta: # (подробнее смотри след. приложение)
        model = User
        fields = ('username', 'password')
```
и вот теперь - ВСЕ! (там еще упомянается CSRF токен, о нем тоже дальше)

### Немногоо классе «Meta»

Самое главное:

**Это не метакласс!!!** **`Meta`—  внутренний класс в Django models**

Это просто контейнер класса с некоторыми параметрами (метаданными), прикрепленными к модели. Он определяет такие вещи, как доступные разрешения, связанное имя таблицы базы данных, является ли модель абстрактной или нет, единственное и множественное число версий имени и т. Д.

Краткое объяснение здесь: [Django docs: Models: Meta options](https://docs.djangoproject.com/en/dev/topics/db/models/#meta-options)

Список доступных мета-параметров находится здесь: [Django docs: Model Meta options](https://docs.djangoproject.com/en/dev/ref/models/options/)

Для последней версии Django: [Django docs: Model Meta options](https://docs.djangoproject.com/en/3.0/ref/models/options/)

### CSRF токен

Это байда без которой не работают POST запросы. иными словами, то что считается небезопасным в плане передачи данных однозначно передается через токен, а к таковым отнесены ВСЕ POST запросы. для того чтобы с ним работать — достаточно его просто объявитьв коде html. А для того, чтобы понимать — нужно еще и прошерстить документацию

https://docs.djangoproject.com/en/3.2/ref/csrf/



### Декораторы

они нужны для того, чтобы когда, например пользователь не определен (не авторизован) и производится переход на страницу, где происходит отбор по пользователям - не вскакивала ошибка. Чисто теретически от этой ошибки можно защититься делая проверку на авторизованность пользователя, но при этом такую проверку придется делатьв  каждом контроллере. 
Чтобы этого не делать - придумали декораторы. Они являются стандартной вещью в Джанго.
```python
from django.contrib.auth.decorators import login_required

@login_required
def basket_add(request, product_id)
    …
```
получается что сперва выполнится код из функции @code_required, где проверится авторизованность пользователя, а потом - сама функция вьюшки. 
Эти декораторы являются стандартом дял Lжанго и описываются в файле decorators.py. Раз они там, то этот модуль нужно подключать (в коде написать: from django.contrib.auth.decorators import login_required).
если по обработке декоратора возникнет исключение - то пользователь будет перенаправлен на страницу авторизации. Но тут есть несколько моментов, которые нужно знать о каждом конкретном декораторе, например его зависисмость от глобальных переменных (settings.py). (например логин_реквиред  зависит от LOGIN_URL = '/users/login/', **!в нашем случае!**)



### Пагинация

В джанго встроен класс пагинации, который называется pagination, если поуглить то можно получить исчерпывающий ответ на тему того что он делает и какие у него методы.
В связи с его применением код изменится следующим образом:
контроллер

```python
def products(request, category_id=None, page=1):
    import datetime
    from products.models import Products, ProductsCategory
    
    if category_id:
        products_filter = Products.objects.filter(category_id=category_id) 
            # фильтруем по идентификатору внутри справочника категорий 
            # по значению category_id, которое пришло из переменных вызова функции.
    else:
        products_filter = Products.objects.all()    
    paginator = Paginator(products_filter, 6) # где число - это количесвто товаров на странице
        # создали пагинатор
    try:
        products_paginator = paginator.page(page)
            # получили список товаров на странице page
    except PageNotInteger:
        products_paginator = paginator.page(1)
                # отобразим первую страницу
    except EmptyPage:
        products_paginator = paginator.page(pagintor.num_pages())
                # отобразим вообще все товары
    context = {
            'title': 'GeekShop - каталог наших предложений',
            'date': datetime.datetime.now().today(),
            'products': products_paginator,  # Заменили фильтр на пагинатор
            'category': ProductsCategory.objects.all()
        }
    return render(request, 'products/products.html', context)
```

пространство адресов для products

```python
urlpatterns = [
    path('',products, name = 'index'), # но это уже index не от сайта а от пространства адресов products
    path('<int:category_id>/',products, name = 'category'), # адрес будет ../category/<id> 
    path('page/<int:page>/',products, name = 'page'), 
]
```

часть шаблона products которая отвечает за пагинатор

```html
<nav aria-label="Page navigation example">
    <ul class="pagination justify-content-center">
        <li class="page-item {% if not products.has_previous %} disabled {%endif%}">
            <a class="page-link" 
                href="{% if products.has_previous%} {% url 'products:page' products.previous_page_number%} {% else %} # {%endif%}" 
                tabindex="-1" aria-disabled="true">
                Предыдущая
            </a>
        </li>
        {% for page in products.paginator.page_range %}
            <li class="page-item">
                <a class="page-link" href="{% url 'products:page' page %}">
                    {{page}}
                </a>
            
            </li>
        {%endfor%}
        <li class="page-item {% if not products.has_next %} disabled {%endif%}">
            <a class="page-link" 
                href="{% if products.has_next%} {% url 'products:page' products.next_page_number%} 
                {% else %} # {%endif%}">
                Следующая</a>
        </li>
    </ul>
</nav>
```

### CBV

**Class Based View**

До сих пор при создании контроллеров использовались функции - это FBV - Function Based View. Им на смену приходят CBV - как более ориентированный на ООП вариант программирования. этот способ построения вьюшек основан на базовом классе контроллера (View), который с теми или иными вариантами использования породил несколько классов, дял решения тех или иных задач. 

**Основные из них:**

- ListView - только показывает (выводит) модели
- CreateView - создает объекты в модели (записи в таблице)
- UpdateView - обновляет объекты в модели
- DeleteView - удаляет объекты в модели.

Как правило создается один класс на один шаблон страницы. Исключение из правила - один шаблон страницы на несколько классов и уж тончо не может быть чтобы один класс работал с несколькими страницами (хотя реализовать это в принципе можно). Для того чтобы их использовать нужно их импортировать:

```python
from django.views.generic.list import ListView, CreateView, UpdateView, DeleteView
from django.views.generic.edit import CreateView, UpdateView, DeleteView
```

И далее создавать классы на основе (в качесвте предка) любого из них. само собой разумеется что и импортирваоть нужно их тогда, когда онидействиетльно нужны.
```

И далее создавать классы на основе (в качесвте предка) любого из них. само собой разумеется что и импортирваоть нужно их тогда, когда онидействиетльно нужны.

У них етсь базовый набор параметров (у каждого). Так у:

- ListView - есть model, template_name (модель и шаблон)
- CreateView - model, template_name, form_class, succes_url (модель, шаблон, форма, адрес куда делать редирект)
- UpdateView - model, template_name, form_class, succes_url 
- DeleteView - model, template_name, form_class, succes_url

чтобы не путаться - классы контроллеров, когда создают, называют придерживаясь првила: ИмяМодели+Дейсвтие+View, например: UserListView, UserCreateView, UserUpdateView, UserDeleteView (соответсвтенно наследуя их от соотвествующего класса-предка)

**В общем виде описание класса соответсвует функции**. так класс:

```python
class UserListView(ListView):
    model = User
    template_name = 'admins/admin-users-read.html'
```

соответсвует:

```python
@user_passes_test(lambda u: u.is_staff)
def admin_users(request):
    context = {
        'title': 'GeekShop - Пользователи',
        'users': Users.objects.all()
    }
    return render(request, 'admins/admin-users-read.html', context)
```

но без логики передачи контекста и предварительного выполнения декоратора, но об этом позже.

Вызвать классы как процедуры не получится, поэтому они имеют метод as_view(), через который их можно вызвать так:

```python
path('users/', UserListView.as_view(), name='index')
```

кроме того, поскольку контекст не сформирвоан, то передается список объектов, которые характерны дял каждого класса... (исходя из предка.) - object_list в данном случае там будет замена ключа `` 'users' ``

Поэтому в шалоне тоже изменится часть где используется контекст... с явного указания ключа на формальное использование источника - object_list, из которого фреймворк сам берет нужные данные исходя из модели (ее ведь мы указали)

**Вообще переделать fbv вызов в cbv можно так**:

1. Определить что делает вьюшка и выбрать базовый класс, придумать имя
2. Описать класс, задав его параметры
3. Изменить urls.py если нужно
4. Изменить шаблон, если нужно.

**Теперь перейдем к работе с передаваемым реальным контекстом и декораторами.** 

Поскольку в большинстве случаев передавать один ключ в контексте - слишком мало (например кроме модели нужны еще title и data), то сформирвоать полноценный контекст можно и в классе, делается это через служебный метод, который естьво всех класах:

```python
get_context_data(self, *,object_list=None, **kwargs):
    context = super(UserListView, self).get_context_data() 
    	# получили имевшийся ранее контекст у родителя
        # UserListView, self - у метода super можно не писать…
    context['title'] = 'титул передаваемый в контекст'     
    	# далее работаем с контекстом как и раньше в FBV
        # покольку это словарь
    return context    
```

Но еще остался неясным момент, при котором нужно запустить декоратор перед вызовом функционала, например запретить доступ к странице, пользоватлям, не имеющим прав администратора (staff). в fbv это делалось простым написанием декоратора перед функцией, здесь прмрно тоже самое, но у каждого класса вызывается специальный метод dispatсh, отвечающий за отображени страницы.

```python
from django.utils.decorators import method_decorator

@method_decorator(user_pases_test(lambda u: u.is_staff))
def dispatch(self,request, *args, **kwargs):
    return super().dispatch(request,*args, **kwargs)
```

method_decorator - служебный декоратор, который нужен для запуска декораторов у методов класса, в него мы передаем стандартно метод который ранее декорировали и его параметры запуска.

**Переопределение методов**

Кроме того, внутри класса можно переопределить функционал базового класса - например при удалении объекта модели (записи в таблице)

**итого, шаблон для создания класса для вьюшки будет следующим**

```python
from django.views.generic.list import ListView
from django.views.generic.edit import CreateView, UpdateView, DeleteView
from django.utils.decorators import method_decorator
from django.urls import reverse_lazy

	# …

class <ИмяКласса>(<Предок>): #  ~ ClassNameView
    model = <модель>
    template_name = 'путь к шаблону' 
    	# ~ 'admins/admin-users-read.html'
    form_class = <Форма>
    success_url = reverse_lazy('admins:admin_users')
    
    # работа с контекстом
    def get_context_data(self, *,object_list=None, **kwargs):
    	context = super().get_context_data() 
    		# получили имевшийся ранее контекст у родителя
    	context['title'] = 'титул передаваемый в контекст'     
    		# далее работаем с контекстом как и раньше в FBV
        	# покольку это словарь
    	return context 
    
    # работа с декоратором
    @method_decorator(user_passes_test(lambda u: u.is_staff))
	def dispatch(self,request, *args, **kwargs):
    	return super().dispatch(request,*args, **kwargs)
```

ненужное - удалить. Итого для замены FBV вьюшки на CBV:

было:

```python
@user_passes_test(lambda u: u.is_staff)
def admin_users(request):
    context = {
        'title': 'GeekShop - Пользователи',
        'users': Users.objects.all()
    }
    return render(request, 'admins/admin-users-read.html', context)
```

стало

```python
class UserListView(ListView):
    model = User
    template_name = 'admins/admin-users-read.html'
        
    def get_context_data(self, *,object_list=None, **kwargs):
    	context = super().get_context_data() 
    	context['title'] = 'GeekShop - Пользователи'     
    	return context 
    
    @method_decorator(user_passes_test(lambda u: u.is_staff))
	def dispatch(self,request, *args, **kwargs):
    	return super().dispatch(request,*args, **kwargs)
```

после этого нужно заменить в urls.py функцию на вызов метода as_view() класса и поправить шаблон, где это нужно.
